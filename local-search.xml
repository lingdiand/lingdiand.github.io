<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k8s</title>
    <link href="/2022/03/25/k8s/"/>
    <url>/2022/03/25/k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Kubernetes是一个基于 Docker 的容器集群管理系统，其目的是让用户透过 Kubernetes 集群来进行云端容器集群的管理</p><p><strong>它的本质是一组服务器</strong>（集群），可以在集群的每个节点运行特点的程序，来对节点中的容器进行管理。目的是为了实现资源管理的自动化</p><p>功能：</p><ul><li><p><strong>自我修复</strong>：一旦某个容器奔溃，能够迅速启动新的容器</p></li><li><p><strong>弹性伸缩</strong>：根据需要自动对集群中正在运行的容器调整数量</p></li><li><p><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</p></li><li><p><strong>负载均衡</strong>：如果（1000个）请求启动了多个（5个nginx）容器，能够自动实现请求的负载均衡</p></li><li><p><strong>版本回退</strong>：如果新发布的应用有问题，可以立即回退到原来的版本</p></li><li><p><strong>存储编排</strong>：根据容器自身的需求自动创建存储卷</p></li></ul><h2 id="2-组件"><a href="#2-组件" class="headerlink" title="2. 组件"></a>2. 组件</h2><p>一个k8s集群由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F551%2F4365abaae9bd1352624aa296cdeff097.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641277393&t=3e3f93606c3db833bf5f77c9a842e890"></p><p><strong>master：管理层，负责集群的决策</strong></p><ul><li><strong>API Server</strong>：集群管理操作的入口，不管是kubectl还是HTTP调用来操作Kubernetes集群各种资源，都是通过它的接口进行操作</li><li><strong>Scheduler</strong>：负责集群资源调度，根据调度策略将Pod调度到相应的node节点上</li><li><strong>ControllerManager</strong>：资源对象的控制自动化中心。即监控Node，当故障时转移资源对象，自动修复集群到期望状态。比如程序部署安排、故障检测、自动扩展等</li><li><strong>Etcd</strong>：负责存储集群中各种资源对象的信息。k8s启动后，master和node都会将自身的信息存储到etcd数据库中</li></ul><p><strong>node：工作层，负责为容器提供运行环境</strong></p><ul><li><strong>Kubelet</strong>： 负责Pod内容器的创建、启停。并与Master密切协作实现集群管理（注册自己，汇报Node状态）<ul><li>监听Scheduler组件的任务分配</li><li>挂载pod所需Volume</li><li>下载pod所需Secrets</li><li>通过与docker daemon的交互运行docker容器</li><li>监控、报告pod和node状态到ControllerManager组件</li></ul></li><li><strong>KubeProxy</strong>：负责提供集群内部的服务发现和负载均衡，负责将后端pod访问规则具体为节点上的iptables/ipvs规则</li><li><strong>Docker</strong>：负责镜像管理以及pod和容器的真正运行</li></ul><hr><p><strong>部署Nginx：</strong></p><ol><li>”安装nginx服务的请求“发送至master节点的<strong>API Server</strong>组件</li><li><strong>API Server</strong>调用<strong>Scheduler</strong>组件做出决定（选择哪个node节点）。它会从<strong>etcd</strong>中读取node节点信息，根据一定的算法进行选择，并将结果告诉<strong>API Server</strong></li><li><strong>API Server</strong>调用<strong>ControllerManager</strong>组件去安排这个决定（调度node节点安装nginx）</li><li><strong>ControllerManager</strong>将安排发送给<strong>Kubelet</strong>，<strong>Kubelet</strong>接受到指令后，会通知<strong>Docker</strong>，由<strong>Docker</strong>启动一个nginx的pod（pod是k8s的最小操作单元，容器必须跑在pod中）</li><li>nginx服务运行来了，如果需要访问，就需要通过<strong>KubeProxy</strong>来对pod产生访问的代理，这样外界用户可以访问集群中的nginx访问了</li></ol><blockquote><p>客户（用户）想要增加一个新功能，会联系项目经理（API Server），项目经理通过分析（Scheduler）得知谁来做这个功能，然后通知（ControllerManager）这个小组长（Kubelet），小组长再将工作告诉某个人（Docker）</p></blockquote><h2 id="3-概念"><a href="#3-概念" class="headerlink" title="3. 概念"></a>3. 概念</h2><p><strong>Master</strong>：集群控制节点，每个集群至少有一个master节点负责集群的管控</p><p><strong>Node</strong>：工作负载节点，由master节点分配容器到node工作节点上，node节点上的docker容器负责运行</p><p><strong>Pod</strong>：k8s的最小控制单元，容器运行在pod中，一个pod包含多个容器。通过控制pod进而控制容器</p><p><strong>Controller</strong>：pod控制器，通过它来实现对pod的管理，比如启动、停止</p><p><strong>Service</strong>：pod对外提供服务的统一入口，可以维护同一类的pod</p><p><strong>Label</strong>：标签，用于对pod进行分类</p><p><strong>Namespace</strong>：命名空间，用来隔离pod的运行环境</p><h1 id="二、资源管理"><a href="#二、资源管理" class="headerlink" title="二、资源管理"></a>二、资源管理</h1><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes</p><blockquote><p>部署服务：在k8s集群中运行一个个的容器，并将指定的程序跑在容器中</p><p>k8s的最小管理单元是pod，所以容器要放在<strong>pod</strong>中，k8s并不直接管理<strong>pod</strong>，还是通过**pod控制器(Controller)**来管理pod</p><p>pod提供服务之后，就要访问服务了，这就是<strong>Service</strong>的功能</p></blockquote><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112070956420.png" alt="image-20211207095642065"></p><blockquote><p>学习kubernetes的核心，就是学习如何对集群上的<strong>Pod、Pod控制器、Service、存储</strong>等资源进行操作</p></blockquote><h2 id="1-资源管理方式"><a href="#1-资源管理方式" class="headerlink" title="1.资源管理方式"></a>1.资源管理方式</h2><ul><li><p>命令式对象管理：使用命令去操作kubernetes资源</p><p><code>kubectl run nginx-pod --image=nginx:1.17.1 --port=80</code></p></li><li><p>命令式对象配置：使用命令 + 配置文件去操作kubernetes资源</p><p><code>kubectl create/patch -f nginx-pod.yml</code></p></li><li><p>声明式对象配置：通过<code>apply</code>（创建和更新的结合）命令和配置文件去操作kubernetes资源</p><p><code>kubectl apply -f nginx-pod.yml</code></p></li></ul><h2 id="2-命令式对象管理"><a href="#2-命令式对象管理" class="headerlink" title="2.命令式对象管理"></a>2.命令式对象管理</h2><p>kubectl是kubernetes集群的命令行工具，通过它对集群本身进行管理</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl [command] [type] [name] [flags]<br></code></pre></div></td></tr></table></figure><p><code>command</code>：指定要对资源执行的操作，比如create、get、delete</p><p><code>type</code>：指定资源类型，比如deployment、pod、service</p><p><code>name</code>：指定资源名称，大小写敏感</p><p><code>flags</code>：指定额外的可选参数</p><ul><li><code>-o</code>：格式化显示。-o=yaml，yaml格式显示结果；-o=wide，详细信息</li><li><code>-n/--namespace</code>：查看指定的命名空间，后跟 namespace</li><li><code>--images</code>：指定镜像</li><li><code>--port</code>：暴露端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看所有pod</span><br>kubectl get pod<br><span class="hljs-meta">#</span><span class="bash">查看某个pod</span><br>kubectl get pod pod_name<br><span class="hljs-meta">#</span><span class="bash">查看某个pod，yml输出</span><br>kubectl get pod pod_name -o=yml<br></code></pre></div></td></tr></table></figure><hr><h3 id="command操作"><a href="#command操作" class="headerlink" title="command操作"></a>command操作</h3><table><thead><tr><th align="left">命令分类</th><th align="left">命令</th><th align="left">翻译</th><th align="left">命令作用</th></tr></thead><tbody><tr><td align="left">基本命令</td><td align="left"><strong>create</strong></td><td align="left">创建</td><td align="left">创建一个资源</td></tr><tr><td align="left"></td><td align="left">edit</td><td align="left">编辑</td><td align="left">编辑一个资源</td></tr><tr><td align="left"></td><td align="left"><strong>get</strong></td><td align="left">获取</td><td align="left">获取一个资源</td></tr><tr><td align="left"></td><td align="left">patch</td><td align="left">更新</td><td align="left">更新一个资源</td></tr><tr><td align="left"></td><td align="left"><strong>delete</strong></td><td align="left">删除</td><td align="left">删除一个资源</td></tr><tr><td align="left"></td><td align="left">explain</td><td align="left">解释</td><td align="left">展示资源文档</td></tr><tr><td align="left">运行和调试</td><td align="left"><strong>run</strong></td><td align="left">运行</td><td align="left">在集群中运行一个指定的镜像</td></tr><tr><td align="left"></td><td align="left"><strong>expose</strong></td><td align="left">暴露</td><td align="left">暴露资源为Service</td></tr><tr><td align="left"></td><td align="left"><strong>describe</strong></td><td align="left">描述</td><td align="left">显示资源内部信息</td></tr><tr><td align="left"></td><td align="left"><strong>logs</strong></td><td align="left">日志输出容器在 pod 中的日志</td><td align="left">输出容器在 pod 中的日志</td></tr><tr><td align="left"></td><td align="left">attach</td><td align="left">缠绕进入运行中的容器</td><td align="left">进入运行中的容器</td></tr><tr><td align="left"></td><td align="left">exec</td><td align="left">执行容器中的一个命令</td><td align="left">执行容器中的一个命令</td></tr><tr><td align="left"></td><td align="left">cp</td><td align="left">复制</td><td align="left">在Pod内外复制文件</td></tr><tr><td align="left"></td><td align="left">rollout</td><td align="left">首次展示</td><td align="left">管理资源的发布</td></tr><tr><td align="left"></td><td align="left"><strong>scale</strong></td><td align="left">规模</td><td align="left">扩(缩)容Pod的数量</td></tr><tr><td align="left"></td><td align="left">autoscale</td><td align="left">自动调整</td><td align="left">自动调整Pod的数量</td></tr><tr><td align="left">高级命令</td><td align="left">apply</td><td align="left">create/patch</td><td align="left">通过文件对资源进行配置</td></tr><tr><td align="left"></td><td align="left">label</td><td align="left">标签</td><td align="left">更新资源上的标签</td></tr><tr><td align="left">其他命令</td><td align="left">cluster-info</td><td align="left">集群信息</td><td align="left">显示集群信息</td></tr><tr><td align="left"></td><td align="left">version</td><td align="left">版本</td><td align="left">显示当前Server和Client的版本</td></tr></tbody></table><hr><h3 id="type资源"><a href="#type资源" class="headerlink" title="type资源"></a>type资源</h3><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl api-resources<br></code></pre></div></td></tr></table></figure><table><thead><tr><th align="left">资源分类</th><th align="left">资源名称</th><th align="left">缩写</th><th align="left">资源作用</th></tr></thead><tbody><tr><td align="left">集群级别资源</td><td align="left">nodes</td><td align="left">no</td><td align="left">集群组成部分</td></tr><tr><td align="left"></td><td align="left">namespaces</td><td align="left">ns</td><td align="left">隔离Pod</td></tr><tr><td align="left">pod资源</td><td align="left">pods</td><td align="left">po</td><td align="left">装载容器</td></tr><tr><td align="left">pod资源控制器</td><td align="left">replicationcontrollers</td><td align="left">rc</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">replicasets</td><td align="left">rs</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">deployments</td><td align="left">deploy</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">daemonsets</td><td align="left">ds</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">jobs</td><td align="left"></td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">cronjobs</td><td align="left">cj</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">horizontalpodautoscalers</td><td align="left">hpa</td><td align="left">控制pod资源</td></tr><tr><td align="left"></td><td align="left">statefulsets</td><td align="left">sts</td><td align="left">控制pod资源</td></tr><tr><td align="left">服务发现资源</td><td align="left">services</td><td align="left">svc</td><td align="left">统一pod对外接口</td></tr><tr><td align="left"></td><td align="left">ingress</td><td align="left">ing</td><td align="left">统一pod对外接口</td></tr><tr><td align="left">存储资源</td><td align="left">volumeattachments</td><td align="left"></td><td align="left">存储</td></tr><tr><td align="left"></td><td align="left">persistentvolumes</td><td align="left">pv</td><td align="left">存储</td></tr><tr><td align="left"></td><td align="left">persistentvolumeclaims</td><td align="left">pvc</td><td align="left">存储</td></tr><tr><td align="left">配置资源</td><td align="left">configmaps</td><td align="left">cm</td><td align="left">配置</td></tr><tr><td align="left"></td><td align="left">secrets</td><td align="left"></td><td align="left">配置</td></tr></tbody></table><hr><p>下面以一个namespace / pod的创建和删除简单演示下命令的使用：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建一个namespace，名为dev</span><br>[root@master ~]# kubectl create namespace dev<br>namespace/dev created<br><br><span class="hljs-meta">#</span><span class="bash"> 获取namespace</span><br>[root@master ~]# kubectl get ns<br>NAME              STATUS   AGE<br>default           Active   21h<br>dev               Active   21s<br>kube-node-lease   Active   21h<br>kube-public       Active   21h<br>kube-system       Active   21h<br><br><span class="hljs-meta">#</span><span class="bash"> 在此namespace下创建并运行一个nginx的Pod</span><br>[root@master ~]# kubectl run pod --image=nginx:latest -n dev<br><br><span class="hljs-meta">#</span><span class="bash"> 查看namespace下的pod,不加-n dev默认查询-n default</span><br>[root@master ~]# kubectl get pod -n dev<br>NAME  READY   STATUS    RESTARTS   AGE<br>pod   1/1     Running   0          21s<br><br><span class="hljs-meta">#</span><span class="bash"> 删除指定的pod</span><br>[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7x<br>pod &quot;pod&quot; deleted<br><br><span class="hljs-meta">#</span><span class="bash"> 删除指定的namespace</span><br>[root@master ~]# kubectl delete ns dev<br>namespace &quot;dev&quot; deleted<br></code></pre></div></td></tr></table></figure><h2 id="3-命令式对象配置"><a href="#3-命令式对象配置" class="headerlink" title="3.命令式对象配置"></a>3.命令式对象配置</h2><p><strong>命令式对象管理</strong>使用命令 + 各种参数</p><p><strong>命令式对象配置</strong>使用命令 + 配置文件，配置文件写的就是各种参数</p><ol><li><p>创建一个nginx-pod.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建namespace  dev</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br><br><span class="hljs-comment"># ---分割文件，这是yaml的语法</span><br><span class="hljs-meta">---</span><br><br><span class="hljs-comment"># 创建pod 名为nginxpod，命名空间为上一步创建的dev</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginxpod</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-comment"># 和docker差不多，指定容器名和镜像源</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-containers</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br></code></pre></div></td></tr></table></figure></li><li><p>执行create命令，创建资源</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@master ~]# kubectl create -f nginxpod.yaml<br>namespace/dev created<br>pod/nginxpod created<br></code></pre></div></td></tr></table></figure></li><li><p>执行get命令，查看资源</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看namespace</span><br>[root@master ~]#  kubectl get ns dev<br><span class="hljs-meta">#</span><span class="bash">查看pod</span><br>[root@master ~]#  kubectl get pod -n dev<br><br><span class="hljs-meta">#</span><span class="bash">一起查看，通过nginxpod.yaml</span><br>[root@master ~]#  kubectl get -f nginxpod.yaml<br></code></pre></div></td></tr></table></figure></li><li><p>执行delete命令，删除资源</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@master ~]# kubectl delete -f nginxpod.yaml<br>namespace &quot;dev&quot; deleted<br>pod &quot;nginxpod&quot; deleted<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="4-声明式对象配置"><a href="#4-声明式对象配置" class="headerlink" title="4.声明式对象配置"></a>4.声明式对象配置</h2><p>只有一个命令<code>apply</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 首先执行一次kubectl apply -f yaml文件，发现创建了资源</span><br>[root@master ~]#  kubectl apply -f nginxpod.yaml<br>namespace/dev created<br>pod/nginxpod created<br><br><span class="hljs-meta">#</span><span class="bash"> 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span><br>[root@master ~]#  kubectl apply -f nginxpod.yaml<br>namespace/dev unchanged<br>pod/nginxpod unchanged<br></code></pre></div></td></tr></table></figure><p>声明式对象配置就是使用<code>apply</code>描述一个资源最终的状态（在yaml中定义状态）<br>使用<code>apply</code>操作资源：<br>        如果资源不存在，就创建，相当于<code>kubectl create</code><br>        如果资源已存在，就更新，相当于<code>kubectl patch</code></p><h1 id="三、Namespace"><a href="#三、Namespace" class="headerlink" title="三、Namespace"></a>三、Namespace</h1><p>默认情况下，Pod是可以相互访问的，如果不想让两个Pod之间互相访问，就可以将两个Pod划分到不同的namespace下。k8s通过将集群内部的资源分配到不同的namespace中，形成逻辑上的组，方便不同的组的资源进行隔离使用和管理</p><p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理</p><p><strong>命令方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看</span><br><span class="hljs-meta">#</span><span class="bash"> Active 命名空间正在使用中  Terminating 正在删除命名空间</span><br><span class="hljs-meta">[root@master]#</span><span class="bash"> kubectl  get namespace</span><br>NAME              STATUS   AGE<br>default           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间<br>kube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入<br>kube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）<br>kube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间<br><br><span class="hljs-meta">#</span><span class="bash"> 创建</span><br><span class="hljs-meta">[root@master]#</span><span class="bash"> kubectl create ns njm</span><br>namespace/njm created<br><br><span class="hljs-meta">#</span><span class="bash"> 删除</span><br><span class="hljs-meta">[root@master]#</span><span class="bash"> kubectl delete ns njm</span><br>namespace &quot;njm&quot; deleted<br></code></pre></div></td></tr></table></figure><p><strong>配置方式</strong></p><p>ns-dev.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br></code></pre></div></td></tr></table></figure><p>创建和删除命令</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl create -f ns-dev.yaml<br>kubectl delete -f ns-dev.yaml<br></code></pre></div></td></tr></table></figure><h1 id="四、Label"><a href="#四、Label" class="headerlink" title="四、Label"></a>四、Label</h1><p>在资源上添加标识，用来对它们进行区分和选择。在后续的pod控制器和Service都是通过label来管理pod</p><blockquote><p>namespace可以实现环境隔离，比如隔离dev环境和test环境。而dev环境下又有前端和后端项目，前后端项目之间需要通信，所以不能用namespace，就需要使用Label</p><p>namespace隔离了pod, 所以通过label分组,但不隔离</p></blockquote><p>特点：</p><ul><li>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等</li><li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li><li>Label通常在资源对象定义时确定，也可以在对象创建后动态添加或者删除</li></ul><hr><p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector</p><p>Label用于给某个资源对象定义标识</p><p>Label Selector用于查询指定标签的资源对象</p><ul><li>基于等式的Label Selector：name=slave</li><li>基于集合的Label Selector：name in (master,slave)</li></ul><p><strong>命令方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 打标签  kubectl label 资源类型 资源名 标签</span> <br>[root@master ~]# kubectl label pod nginx-pod -n dev version=1.0<br>pod/nginx-pod labeled<br><br><span class="hljs-meta">#</span><span class="bash"> 查看标签--show-labels</span><br>[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labels<br>NAME        READY   STATUS    RESTARTS   AGE   LABELS<br>nginx-pod   1/1     Running   0          10m   version=1.0<br><br><span class="hljs-meta">#</span><span class="bash"> 修改标签--overwrite</span><br>[root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwrite<br>pod/nginx-pod labeled<br><br><span class="hljs-meta">#</span><span class="bash"> 筛选pod，根据标签</span><br>[root@master ~]# kubectl get pod -n dev -l version=2.0 --show-labels<br><br><span class="hljs-meta">#</span><span class="bash"> 删除标签  标签名-</span><br>[root@master ~]# kubectl label pod nginx-pod -n dev version-<br></code></pre></div></td></tr></table></figure><p><strong>配置方式</strong></p><p>pod-nginx.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span> <br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></div></td></tr></table></figure><p>执行命令：<code>kubectl apply -f pod-nginx.yaml </code></p><h1 id="五、Pod"><a href="#五、Pod" class="headerlink" title="五、Pod"></a>五、Pod</h1><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112071433991.png" alt="image-20211207143321015"></p><p>Pod可以认为是容器的封装，Pod中可包含一个或多个容器，容器可分为两类</p><ul><li>用户程序定义的容器</li><li>Pause容器。这是每个Pod都会有的一个<strong>根容器</strong>，作用：<ul><li>以它为依据，评估整个Pod的健康状态</li><li>可以在根容器设置ip地址，其他容器共享此ip，实现Pod内部网络通讯</li></ul></li></ul><hr><p><strong>查看Pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> -n kube-system 查看命名空间为kube-system的pod</span> <br>kubectl get pod -n kube-system<br></code></pre></div></td></tr></table></figure><p><strong>创建并运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令格式： kubectl run (pod名称) [参数]</span> <br><span class="hljs-meta">#</span><span class="bash"> --image  指定Pod的镜像</span><br><span class="hljs-meta">#</span><span class="bash"> --port   指定端口</span><br><span class="hljs-meta">#</span><span class="bash"> --namespace  指定namespace</span><br><br><span class="hljs-meta">#</span><span class="bash"> 运行一个名称为nginx的pod</span><br>[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev <br>pod/nginx created<br></code></pre></div></td></tr></table></figure><p><strong>查看Pod</strong>，注意要加上命名空间</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看Pod基本信息</span><br>[root@master ~]# kubectl get pod -n dev<br>NAME    READY   STATUS    RESTARTS   AGE<br>nginx   1/1     Running   0          43s<br><br><span class="hljs-meta">#</span><span class="bash"> 查看Pod的详细信息</span><br>[root@master ~]# kubectl describe pod nginx -n dev<br></code></pre></div></td></tr></table></figure><p><strong>删除Pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@master ~]# kubectl delete pod nginx -n dev<br></code></pre></div></td></tr></table></figure><hr><p><strong>通过配置文件操作</strong></p><p>nginx-pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br><span class="hljs-comment"># 这个name指的是pod</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></div></td></tr></table></figure><p>创建和删除命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">kubectl create -f nginx-pod.yaml<br>kubectl delete -f nginx-pod.yaml<br></code></pre></div></td></tr></table></figure><hr><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p><strong>可以使用explain查看某种类型的可配置项</strong></p><p><code>kebectl explain 资源类型</code>     查看一级属性</p><p><code>kebectl explain 资源类型.属性</code>    查看属性的子属性</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master01 ~]# kubectl explain pod<br>KIND:     Pod<br>VERSION:  v1<br>FIELDS:#一级属性<br>   apiVersion   &lt;string&gt;<br>   kind &lt;string&gt;<br>   metadata     &lt;Object&gt;<br>   spec &lt;Object&gt;<br>   status       &lt;Object&gt;<br>[root@k8s-master01 ~]# kubectl explain pod.metadata<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: metadata &lt;Object&gt;<br>FIELDS:# pod的metadate属性<br>   annotations  &lt;map[string]string&gt;<br>   clusterName  &lt;string&gt;<br>   creationTimestamp    &lt;string&gt;<br>   deletionGracePeriodSeconds   &lt;integer&gt;<br>   deletionTimestamp    &lt;string&gt;<br>   finalizers   &lt;[]string&gt;<br>   generateName &lt;string&gt;<br>   generation   &lt;integer&gt;<br>   labels       &lt;map[string]string&gt;<br>   managedFields        &lt;[]Object&gt;<br>   name &lt;string&gt;<br>   namespace    &lt;string&gt;<br>   ownerReferences      &lt;[]Object&gt;<br>   resourceVersion      &lt;string&gt;<br>   selfLink     &lt;string&gt;<br>   uid  &lt;string&gt;<br></code></pre></div></td></tr></table></figure><p>一级属性：</p><ul><li>apiVersion <string> ：版本，由k8s内部定义，版本号必须可以用 <code>kubectl api-versions</code> 查询到</li><li>kind <string> ：资源类型，由k8s内部定义，版本号必须可以用 <code>kubectl api-resources</code> 查询到</li><li>metadata <Object> ：元数据，主要是资源标识和说明，常用的有name、namespace、labels等</li><li><strong>spec <Object> ：描述</strong>，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li><li>status <Object> ：状态信息，不需要定义，由k8s自动生成</li></ul><p>spec的常见子属性：</p><ul><li><p>containers &lt;[]Object&gt;：容器列表，定义容器的详细信息</p></li><li><p>nodeName &lt;[]Object&gt;：根据nodeName将pod调度至指定的Node节点上 </p></li><li><p>nodeSelector &lt;map[]&gt;：根据NodeSelector（标签）将pod调度到包含这些label的Node节点上</p></li><li><p>hostNetwork <boolean> ：是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</p></li><li><p>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</p></li><li><p>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</p></li></ul><hr><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><blockquote><p>2.配置中介绍的都是containers 的子属性</p></blockquote><p><code>pod.spec.containers </code>属性</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master01 ~]# kubectl explain pod.spec.containers<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器<br>FIELDS:<br>   name  &lt;string&gt;     # 容器名称<br>   image &lt;string&gt;     # 容器需要的镜像地址<br>   imagePullPolicy  &lt;string&gt; # 镜像拉取策略 <br>   command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令<br>   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表<br>   env      &lt;[]Object&gt; # 容器环境变量的配置<br>   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表<br>   resources &lt;Object&gt;      # 资源限制和资源请求的设置<br></code></pre></div></td></tr></table></figure><p><strong>创建pod-base.yaml文件</strong></p><p>创建pod，名为pod-base，命名空间为dev，标签user:niujiaming。创建了两个容器</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-base</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">niujiaming</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx01</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx02</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建Pod</span><br>[root@k8s-master01 pod]# kubectl apply -f pod-base.yaml<br>pod/pod-base created<br><br><span class="hljs-meta">#</span><span class="bash"> 查看Pod状况</span><br>[root@k8s-master01 pod]# kubectl get pod -n dev<br><br><span class="hljs-meta">#</span><span class="bash"> 可以通过describe查看内部的详情</span><br>[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev<br></code></pre></div></td></tr></table></figure><h3 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h3><p>创建pod-imagepullpolicy.yaml文件</p><p>imagePullPolicy，用于设置镜像拉取策略</p><ul><li>Always：一直远程下载</li><li>IfNotPresent：本地有就本地 本地没远程下载</li><li>Never：一直使用本地</li></ul><blockquote><p>如果镜像tag为具体版本号，拉取策略为IfNotPresent</p><p>如果没有镜像tag（默认latest），拉取策略为Always</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-imagepullpolicy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 本地拉取，没有就失败</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx02</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></div></td></tr></table></figure><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>用于在pod中的容器初始化完毕之后运行一个命令</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: pod-command<br>  namespace: dev<br>spec:<br>  containers:<br>  - name: busybox<br>    image: busybox:1.30<br>    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;]<br></code></pre></div></td></tr></table></figure><blockquote><p>“/bin/sh”,”-c”, 使用sh执行命令</p><p>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</p><p>while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建Pod</span><br>[root@k8s-master01 pod]# kubectl create  -f pod-command.yaml<br><br><span class="hljs-meta">#</span><span class="bash"> 进入pod中的busybox容器，查看文件内容</span><br><span class="hljs-meta">#</span><span class="bash"> kubectl <span class="hljs-built_in">exec</span>  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行的命令</span><br><span class="hljs-meta">#</span><span class="bash"> 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span><br><span class="hljs-meta">#</span><span class="bash"> 比如，可以查看txt文件的内容</span><br>[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh<br>/ # tail -f /tmp/hello.txt<br>14:44:19<br>14:44:22<br>14:44:25<br></code></pre></div></td></tr></table></figure><p><strong>args</strong></p><p>command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。</p><ol><li>如果command和args均没有写，那么用Dockerfile的配置。</li><li>如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command</li><li>如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数</li><li> 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</li></ol><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>env，用于在pod容器中设计环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">envar-demo</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">purpose:</span> <span class="hljs-string">demonstrate-envars</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">envar-demo-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google-samples/node-hello:1.0</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-comment"># 定义一个名为DEMO_GREETING值为&quot;Hello from the environment&quot;的环境变量</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">DEMO_GREETING</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;Hello from the environment&quot;</span><br></code></pre></div></td></tr></table></figure><p>运行后使用<code>kubectl exec -it envar-demo -- /bin/bash</code>进入容器中，使用<code>printenv</code>查看环境变量</p><h3 id="端口设置"><a href="#端口设置" class="headerlink" title="端口设置"></a>端口设置</h3><p>ports支持的子选项</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master ~]# kubectl explain pod.spec.containers.ports<br>KIND:     Pod<br>VERSION:  v1<br>RESOURCE: ports &lt;[]Object&gt;<br>FIELDS:<br>   containerPort&lt;integer&gt;#容器端口。必填，容器要监听的端口<br>   hostIP       &lt;string&gt;#主机IP。要将外部端口绑定到主机IP，一般省略<br>   hostPort     &lt;integer&gt;#主机端口。容器要在主机上公开的端口，一般省略<br>   name&lt;string&gt;#端口名字<br>   protocol     &lt;string&gt;#端口协议，默认TCP<br></code></pre></div></td></tr></table></figure><p>pod-ports.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-ports</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.10</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 设置容器暴露的端口列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></div></td></tr></table></figure><h3 id="资源配额"><a href="#资源配额" class="headerlink" title="资源配额"></a>资源配额</h3><p>程序运行要占用资源，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其他容器无法运行。k8s通过<strong>resources</strong>选项实现资源分配，它有两个子选项规定容器的上下限：</p><ul><li><p>requets：下限。设置容器需要的最小资源，不够不启动容器</p></li><li><p>limits：上限。限制运行时容器的最大占用资源，超过就重启容器</p></li></ul><p>pod-resources.yaml</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: pod-resources<br>  namespace: dev<br>spec:<br>  containers:<br>  - name: nginx<br>    image: nginx:1.17.1<br>    resources: # 资源配额<br>      limits:  # 限制资源（上限）<br>        cpu: &quot;2&quot; # CPU限制，单位是core数<br>        memory: &quot;10Gi&quot; #内存大小，可以使用Gi、Mi、G、M等形式<br>      requests: # 请求资源（下限）<br>        cpu: &quot;1&quot;<br>        memory: &quot;10Mi&quot; <br></code></pre></div></td></tr></table></figure><h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><p>pod对象从<strong>创建到终止</strong>的这段时间范围称为pod的生命周期，包括：</p><ul><li>pod创建过程</li><li>运行初始化容器（init container）过程</li><li>运行主容器（main container 用户容器）过程<ul><li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li><li>容器的存活性探测（liveness probe）、就绪性探测（readiness  probe）</li></ul></li><li>pod终止过程</li></ul><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112131508755.png" alt="image-20211213150831069"></p><p>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p><ul><li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li><li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li><li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li><li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li><li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li></ul><h3 id="创建和终止"><a href="#创建和终止" class="headerlink" title="创建和终止"></a>创建和终止</h3><p><strong>pod的创建过程</strong></p><ol><li>用户通过<code>kubectl</code>提交要创建的pod信息给<code>apiServer</code></li><li><code>apiServer</code>生成pod对象信息并存入etcd，然后确认信息</li><li><code>apiServer</code>开始反应etcd中pod对象的变化，其他组件使用watch机制来跟踪检查<code>apiService</code>上的变动</li><li><code>scheduler</code>发现有新的pod要创建，为pod分配主机并将结果更新给<code>apiServer</code></li><li>node节点的<code>kubectl</code>发现有pod调度过来，尝试用docker启动容器，并将结果返回给<code>apiServer</code></li><li><code>apiServer</code>将接收到的pod状态信息存入etcd中</li></ol><p><strong>pod的终止过程</strong></p><ol><li>用户通过<code>kubectl</code>提交要删除的pod信息给<code>apiServer</code></li><li>在删除前需要停止容器，在宽限期内（默认30s），pod被视为dead</li><li>将pod标记为terminating状态</li><li><code>kubectl</code>监控到pod处于terminating状态，同时启动pod关闭过程 </li><li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li><li>如果pod定义了preStop钩子处理器，则在其标记为terminating后会以同步的方式启动执行</li><li>pod容器进程收到停止信号</li><li>宽限期结束后，若pod还存在运行的进程，那么pod对象会收到立即终止的信号</li><li><code>kubectl</code>请求<code>apiServer</code>将此pod资源的宽限期设置为0从而完成删除</li></ol><h3 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h3><p>初始化容器不是一个动作，而是在pod主容器启动之前要运行的容器，主要是做一些主容器的前置工作（比如环境），具有两大特征：</p><ol><li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么k8s需要重启它直到成功完成</li><li>初始化容器必须按照定义的顺序执行，当前一个成功后，后面的一个才能运行（初始化容器有多个）</li></ol><p>初始化容器有很多的应用场景，比如：</p><ul><li>提供主容器镜像中不具备的工具程序或自定义代码</li><li>初始化容器要先于应用容器串行启动并运行成功，可用于延后应用容器的启动（类似DockerCompose中的depends_on依赖关系）</li></ul><hr><p>pod-initcontainer.yaml</p><blockquote><p>initContainers属性和containers是同级的</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-initcontainer</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">initContainers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">xxxx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx</span><br></code></pre></div></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p><blockquote><p>类似初始化容器，不过初始化容器的单位是容器，容器启动成功则继续，而这个是函数</p></blockquote><p>kubernetes在主容器的<strong>启动之后</strong>和<strong>停止之前</strong>提供了两个钩子函数：</p><ul><li>post start：容器<strong>创建之后</strong>执行，如果失败了会重启容器</li><li>pre stop ：容器<strong>终止之前</strong>执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li></ul><p>钩子处理器提供了三种方式定义动作：</p><ol><li><p>Exec命令：在容器内执行一次命令</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lifecycle:</span><br>  <span class="hljs-attr">postStart:</span> <br>    <span class="hljs-attr">exec:</span><br>      <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br></code></pre></div></td></tr></table></figure></li><li><p>TCPSocket：在当前容器尝试访问指定的socket</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lifecycle:</span><br>  <span class="hljs-attr">postStart:</span><br>    <span class="hljs-attr">tcpSocket:</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></div></td></tr></table></figure></li><li><p>HTTPGet：在当前容器中向某url发起http请求</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">lifecycle:</span><br>  <span class="hljs-attr">postStart:</span><br>    <span class="hljs-attr">httpGet:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment">#URI地址</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.70</span><span class="hljs-number">.28</span> <span class="hljs-comment">#主机地址</span><br>      <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br>      <span class="hljs-comment">#拼起来就是http://192.168.70.28:80</span><br></code></pre></div></td></tr></table></figure></li></ol><p><strong>exec</strong>例子</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-hook-exec</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">lifecycle:</span><br>      <span class="hljs-attr">postStart:</span> <br>        <span class="hljs-attr">exec:</span> <span class="hljs-comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]<br>      <span class="hljs-attr">preStop:</span><br>        <span class="hljs-attr">exec:</span> <span class="hljs-comment"># 在容器停止之前停止nginx服务</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/usr/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;quit&quot;</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">[root@k8s-master hook-test]<span class="hljs-comment"># kubectl create -f pod-hook-exec.yaml </span><br>pod/pod-hook-exec created<br>[root@k8s-master hook-test]<span class="hljs-comment"># kubectl get pod -n njm -o wide</span><br>NAME            READY   STATUS    RESTARTS   AGE   IP             NODE            NOMINATED NODE   READINESS GATES<br>pod-hook-exec   1/1     Running   0          15s   172.29.16.32   192.168.70.28   &lt;none&gt;           &lt;none&gt;<br>[root@k8s-master hook-test]<span class="hljs-comment"># curl 172.29.16.32:80</span><br>postStart...<br></code></pre></div></td></tr></table></figure><h3 id="容器探测"><a href="#容器探测" class="headerlink" title="容器探测"></a>容器探测</h3><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p><ul><li>liveness probes：存活性探针，用于检测应用实例当前是否处于<strong>正常运行状态</strong>，如果不是，k8s会重启容器</li><li>readiness probes：就绪性探针，用于检测应用实例当前是否可以<strong>接收请求</strong>，如果不能，k8s不会转发流量（ready 变y为i加ness）</li></ul><blockquote><p>livenessProbe 决定是否重启容器</p><p>readinessProbe 决定是否将请求转发给容器</p></blockquote><p>探针方式：</p><ul><li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">livenessProbe:</span><br>  <span class="hljs-attr">exec:</span><br>    <span class="hljs-attr">command:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp/healthy</span><br></code></pre></div></td></tr></table></figure></li><li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">livenessProbe:</span><br>  <span class="hljs-attr">tcpSocket:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></div></td></tr></table></figure></li><li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">livenessProbe:</span><br>  <span class="hljs-attr">httpGet:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/</span> <span class="hljs-comment">#URI地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment">#主机地址</span><br>    <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br></code></pre></div></td></tr></table></figure></li></ul><p><strong>liveness probes（存活性探针）例子</strong></p><ol><li><p><strong>Exec命令</strong>  pod-liveness-exec.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-exec</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">exec:</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/cat&quot;</span>,<span class="hljs-string">&quot;/tmp/hello.txt&quot;</span>] <span class="hljs-comment"># 执行一个查看文件的命令(这个文并不存在)</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建</span><br>[root@k8s-master probes-test]# kubectl create -f pod-liveness-test.yaml <br>pod/pod-liveness-exec created<br><br><span class="hljs-meta">#</span><span class="bash">查看，RESTARTS重启了一次</span><br>[root@k8s-master probes-test]# kubectl get pod -n njm<br>NAME                READY   STATUS    RESTARTS   AGE<br>pod-liveness-exec   1/1     Running   1          63s<br></code></pre></div></td></tr></table></figure><p>查看详情，提示探测失败，容器将被重启</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112141634425.png" alt="image-20211214163426890"></p></li><li><p><strong>TCPSocket</strong>  pod-liveness-tcpsocket.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-tcpsocket</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">tcpSocket:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 尝试访问8080端口</span><br></code></pre></div></td></tr></table></figure><p>同样的创建、查看</p><p>nginx的端口为80，所以会失败</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112141640339.png" alt="image-20211214164003174"></p></li><li><p><strong>HTTPGet</strong>   pod-liveness-httpget.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-liveness-httpget</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">httpGet:</span>  <span class="hljs-comment"># 其实就是访问http://127.0.0.1:80/hello  </span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span> <span class="hljs-comment">#支持的协议，http或者https</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#端口号</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span> <span class="hljs-comment">#URI地址</span><br></code></pre></div></td></tr></table></figure><p>出现404错误，将会重启</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112141649755.png" alt="image-20211214164926386"></p></li></ol><h3 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h3><p>探测中如果容器出了问题会重启，而重启是由重启策略决定的，有三种：</p><ol><li>Always（默认）：容器失效时，自动重启该容器</li><li>OnFailure： 容器终止运行且退出码不为0时重启</li><li>Never： 不论状态为何，都不重启该容器</li></ol><p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s（最大）</p><p>pod-restartpolicy.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-restartpolicy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/hello</span><br>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 设置的是pod的重启策略，所以和containers同一级别，设置重启策略为Never                 </span><br></code></pre></div></td></tr></table></figure><p>探测失败后停止容器</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112141701405.png" alt="image-20211214170101271"></p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112141701618.png" alt="image-20211214170137699"></p><h2 id="4-调度"><a href="#4-调度" class="headerlink" title="4.调度"></a>4.调度</h2><p>Pod在哪个node节点上运行，是由scheduler组件决定的，这个过程不受人工控制。如果我们想控制某些Pod到达某些节点上，就需要改变调度规则，k8s提供了4种调度方式</p><ol><li>自动调度：顾名思义，自动</li><li>定向调度：NodeName、NodeSelector</li><li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li><li>污点（容忍）调度：Taints、Toleration</li></ol><h3 id="定向调度"><a href="#定向调度" class="headerlink" title="定向调度"></a>定向调度</h3><p>通过在pod上声明nodeName或nodeSelector，以此将Pod调度到期望的node节点上</p><h4 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a><strong>NodeName</strong></h4><p>NodeName强制将Pod调度到指定的Name的Node节点上（即使NodeName不存在）,跳过了scheduler</p><p>创建一个pod-nodename.yaml文件</p><blockquote><p>nodeName是pod的属性，和containers同级</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodename</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">node1</span> <span class="hljs-comment"># 指定调度到node1节点上</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建</span><br>[root@k8s-master dispatch-test]# kubectl create -f pod-nodename.yaml <br>pod/pod-nodename created<br><br><span class="hljs-meta">#</span><span class="bash">查看，由于不存在node3节点，所以pod无法正常运行</span><br>[root@k8s-master dispatch-test]# kubectl get pod -n njm -o wide<br>NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    NOMINATED NODE   READINESS GATES<br>pod-nodename   0/1     Pending   0          45s   &lt;none&gt;   node1   &lt;none&gt;           &lt;none&gt;<br><br></code></pre></div></td></tr></table></figure><h4 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a><strong>NodeSelector</strong></h4><p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束</p><p>需要先给node节点添加标签</p><p>创建一个pod-nodeselector.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodeselector</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">nodeSelector:</span> <br>    <span class="hljs-attr">nodeenv:</span> <span class="hljs-string">pro</span> <span class="hljs-comment"># 指定调度到具有nodeenv=pro标签的节点上</span><br></code></pre></div></td></tr></table></figure><p>创建并运行，提示node selector匹配失败的提示</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112151353871.png" alt="image-20211215135344439"></p><h3 id="亲和性调度"><a href="#亲和性调度" class="headerlink" title="亲和性调度"></a>亲和性调度</h3><p>它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有<strong>，也可以调度到不满足条件的节点</strong>上，使调度更加灵活</p><p><strong>Affinity</strong>主要分为三类：</p><ol><li><strong>nodeAffinity</strong>(node亲和性）: 以node为目标，解决pod<strong>可以调度到哪些node</strong>的问题</li><li><strong>podAffinity</strong>(pod亲和性) : 以pod为目标，解决pod可<strong>以和哪些已存在的pod部署在同一个</strong>拓扑域中的问题</li><li><strong>podAntiAffinity</strong>(pod反亲和性) : 以pod为目标，解决pod<strong>不能和哪些已存在pod部署在同一个</strong>拓扑域中的问题</li></ol><blockquote><p>关于亲和性(反亲和性)使用场景的说明：</p><p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗</p><p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用</p></blockquote><hr><h4 id="NodeAffinity"><a href="#NodeAffinity" class="headerlink" title="NodeAffinity"></a><strong>NodeAffinity</strong></h4><p>NodeAffinity主要实现以Node为参照，实现让新创建的Pod在指定的Node中</p><p><code>NodeAffinity</code>的可配置项：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pod.spec.affinity.nodeAffinity<br>  requiredDuringSchedulingIgnoredDuringExecution  #Node节点必须满足指定的所有规则才可以，相当于硬限制<br>    nodeSelectorTerms  #节点选择列表<br>      matchFields   #按节点字段列出的节点选择器要求列表<br>      matchExpressions   #按节点标签列出的节点选择器要求列表(推荐)<br>        key    #键<br>        values #值<br>        operat or #关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt<br>        <br>  preferredDuringSchedulingIgnoredDuringExecution #优先调度到满足指定的规则的Node，相当于软限制 (倾向)<br>    preference   #一个节点选择器项，与相应的权重相关联<br>      matchFields   #按节点字段列出的节点选择器要求列表<br>      matchExpressions   #按节点标签列出的节点选择器要求列表(推荐)<br>        key    #键<br>        values #值<br>        operator #关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt<br>weight #倾向权重，在范围1-100<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">关系符的使用说明:<br>- matchExpressions:<br>  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点<br>    operator: Exists<br>  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点<br>    operator: In<br>    values: [&quot;xxx&quot;,&quot;yyy&quot;]<br>  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点<br>    operator: Gt<br>    values: &quot;xxx&quot;<br></code></pre></div></td></tr></table></figure><hr><p>演示<code>preferredDuringSchedulingIgnoredDuringExecution</code> </p><p>创建pod-nodeaffinity-preferred.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-nodeaffinity-preferred</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">nodeAffinity:</span> <span class="hljs-comment">#设置node亲和性</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配nodeenv的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">nodeenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>NodeAffinity规则设置的注意事项：</p><div class="hljs code-wrapper"><pre><code>1. 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上2. 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可3. 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功4. 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</code></pre></div><hr><h4 id="PodAffinity"><a href="#PodAffinity" class="headerlink" title="PodAffinity"></a><strong>PodAffinity</strong></h4><p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能</p><p><code>PodAffinity</code>的可配置项：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pod.spec.affinity.podAffinity<br>  requiredDuringSchedulingIgnoredDuringExecution  #硬限制<br>    namespaces       #指定参照pod的namespace<br>    topologyKey      #指定调度作用域<br>    labelSelector    #标签选择器<br>      matchExpressions  #按节点标签列出的节点选择器要求列表(推荐)<br>        key    #键<br>        values #值<br>        operator #关系符 支持In, NotIn, Exists, DoesNotExist.<br>      matchLabels    #指多个matchExpressions映射的内容<br>  preferredDuringSchedulingIgnoredDuringExecution #软限制<br>    podAffinityTerm  #选项<br>      namespaces      <br>      topologyKey<br>      labelSelector<br>        matchExpressions  <br>          key    #键<br>          values #值<br>          operator<br>        matchLabels <br>    weight #倾向权重，在范围1-100<br></code></pre></div></td></tr></table></figure><p>topologyKey用于指定调度时作用域,例如:<br>    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围<br>    如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</p><p>演示<code>requiredDuringSchedulingIgnoredDuringExecution</code></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-podaffinity-required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">podAffinity:</span> <span class="hljs-comment">#设置pod亲和性</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配podenv的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">podenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;yyy&quot;</span>]<br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></div></td></tr></table></figure><p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上</p><hr><h4 id="PodAntiAffinity"><a href="#PodAntiAffinity" class="headerlink" title="PodAntiAffinity"></a><strong>PodAntiAffinity</strong></h4><p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod<strong>不在一个区域中</strong></p><p>配置方式和选项跟PodAffinty是一样的</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-podantiaffinity-required</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">affinity:</span>  <span class="hljs-comment">#亲和性设置</span><br>    <span class="hljs-attr">podAntiAffinity:</span> <span class="hljs-comment">#设置pod亲和性</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬限制</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">podenv</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;pro&quot;</span>]<br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></div></td></tr></table></figure><h3 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h3><h4 id="污点（Taints）"><a href="#污点（Taints）" class="headerlink" title="污点（Taints）"></a>污点（Taints）</h4><p>前面的调度方式都是站在Pod的角度上，通过Pod，决定<strong>Pod要调度到哪一个Node</strong>上，我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，<strong>来决定Node是否允许Pod调度过来</strong></p><p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去</p><p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，有三个选项：</p><ul><li><strong>PreferNoSchedule（委婉拒绝，除非没办法）</strong>：将<strong>尽量避免</strong>把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li><li><strong>NoSchedule（拒绝新的pod）</strong>：将<strong>不会</strong>把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li><li><strong>NoExecute（拒绝新的pod和在这的pod）</strong>：将<strong>不会</strong>把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod<strong>驱离</strong></li></ul><p>使用kubectl设置和去除污点的命令示例如下：</p><p> <code>kubectl taint nodes 节点名 污点</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置污点</span><br>kubectl taint nodes node1 key=value:effect<br><span class="hljs-meta">#</span><span class="bash"> 去除某个污点</span><br>kubectl taint nodes node1 key:effect-<br><span class="hljs-meta">#</span><span class="bash"> 去除所有污点</span><br>kubectl taint nodes node1 key-<br><br><span class="hljs-meta">#</span><span class="bash"> 为node1设置污点(PreferNoSchedule)</span><br>[root@k8s-master01 ~]# kubectl taint nodes node1 tag=taint:PreferNoSchedule<br></code></pre></div></td></tr></table></figure><h4 id="容忍（Toleration）"><a href="#容忍（Toleration）" class="headerlink" title="容忍（Toleration）"></a>容忍（Toleration）</h4><p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong></p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112151732124.png" alt="image-20211215173159089"></p><blockquote><p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pod-toleration</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>  <span class="hljs-attr">tolerations:</span>      <span class="hljs-comment"># 添加容忍</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;tag&quot;</span>        <span class="hljs-comment"># 要容忍的污点的key</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span> <span class="hljs-comment"># 操作符</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;taint&quot;</span>    <span class="hljs-comment"># 容忍的污点的value</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span>   <span class="hljs-comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span><br></code></pre></div></td></tr></table></figure><p>容忍的详细配置:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations<br>......<br>FIELDS:<br>   key       # 对应着要容忍的污点的键，空意味着匹配所有的键<br>   value     # 对应着要容忍的污点的值<br>   operator  # key-value的运算符，支持Equal和Exists（默认）<br>   effect    # 对应污点的effect，空意味着匹配所有影响<br>   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间<br></code></pre></div></td></tr></table></figure><h1 id="六、Pod控制器"><a href="#六、Pod控制器" class="headerlink" title="六、Pod控制器"></a>六、Pod控制器</h1><p>按照pod的创建方式可以分为两类：</p><ul><li>自主式pod：<strong>直接创建出来的pod</strong>，这种pod删除后就没有了，也不会重建</li><li>控制器创建的pod：<strong>通过控制器创建的pod</strong>，这种pod删除了之后还会自动重建</li></ul><p>Pod控制器是管理pod的中间层，通过pod控制器，可以规定需要多少个什么样的pod，如果pod在运行出现故障，pod控制器会基于指定策略重启pod</p><p>pod控制器有很多种，每种都有自己的适合场景：</p><ul><li>ReplicationController：已经被废弃，由ReplicaSet替代</li><li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li><li><strong>Deployment</strong>：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li><li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li><li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li><li>Job：它创建出来的pod只要完成任务就立即退出，用于执行一次性任务</li><li>Cronjob：它创建的Pod和周期性的执行，用于执行周期性任务</li><li>StatefulSet：管理有状态应用</li></ul><h2 id="1-ReplicaSet-rs"><a href="#1-ReplicaSet-rs" class="headerlink" title="1.ReplicaSet(rs)"></a>1.ReplicaSet(rs)</h2><p>简称RS，主要<strong>保证一定数量的pod能够正常运行</strong>，它会持续监听这些pod的运行状态，一旦pod发生故障就会重启或重建，同时还支持对pod数量的扩缩容和版本镜像的升级</p><p>yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">rs</span><br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span>  <span class="hljs-comment"># 即管理标签为app:nginx-pod的pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>      <br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><p><code>spec</code>下面几个选项：</p><ul><li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p></li><li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制</p><p>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p></li><li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是pod的定义</p></li></ul><hr><p><strong>创建ReplicaSet</strong></p><p>创建replicaset.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span>   <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-replicaset</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span> <br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建rs</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl create -f replicaset.yaml</span> <br>replicaset.apps/pc-replicaset created<br><br><span class="hljs-meta">#</span><span class="bash">查看rs</span><br><span class="hljs-meta">#</span><span class="bash"> desire:期望副本数量</span>  <br><span class="hljs-meta">#</span><span class="bash"> current:当前副本数量</span>  <br><span class="hljs-meta">#</span><span class="bash"> ready:已经准备好提供服务的副本数量</span><br><span class="hljs-meta">[root@k8s-mastert]#</span><span class="bash"> kubectl get rs -n njm -o wide</span><br>NAME            DESIRED   CURRENT   READY   AGE    CONTAINERS   IMAGES         SELECTOR<br>pc-replicaset   3         3         3       2m8s   nginx        nginx:1.17.1   app=nginx-pod<br><br><span class="hljs-meta">#</span><span class="bash">查看pod</span><br><span class="hljs-meta">#</span><span class="bash">这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get pod -n njm</span> <br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-84rcb   1/1     Running   0          3m35s<br>pc-replicaset-k6rxm   1/1     Running   0          3m35s<br>pc-replicaset-kmn5m   1/1     Running   0          3m35s<br><br></code></pre></div></td></tr></table></figure><hr><p><strong>扩缩容</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编辑rs的副本数量，修改spec:replicas: 6即可</span><br>[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n njm<br>replicaset.apps/pc-replicaset edited<br><br><span class="hljs-meta">#</span><span class="bash"> 当然也可以直接使用命令实现</span><br><span class="hljs-meta">#</span><span class="bash"> 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span><br>[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n njm<br>replicaset.apps/pc-replicaset scaled<br></code></pre></div></td></tr></table></figure><p><strong>镜像更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编辑rs的容器镜像 - image: nginx:1.17.2</span><br>[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n njm<br>replicaset.apps/pc-replicaset edited<br><br><span class="hljs-meta">#</span><span class="bash"> 使用命令kubectl <span class="hljs-built_in">set</span> image rs rs名称 容器=镜像版本 -n namespace</span><br>[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.2  -n njm<br>replicaset.apps/pc-replicaset image updated<br></code></pre></div></td></tr></table></figure><p><strong>删除ReplicaSet</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 使用kubectl delete命令会删除此RS以及它管理的Pod</span><br><span class="hljs-meta">#</span><span class="bash"> 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span><br>[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br><br><span class="hljs-meta">#</span><span class="bash"> 也可以使用yaml直接删除</span><br>[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yaml<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br><br><span class="hljs-meta">#</span><span class="bash"> 如果只删除RS对象（保留Pod），可以使用添加--cascade=<span class="hljs-literal">false</span>（级联删除=<span class="hljs-literal">false</span>）</span><br>[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=false<br>replicaset.apps &quot;pc-replicaset&quot; deleted<br>[root@k8s-master01 ~]# kubectl get pods -n dev<br>NAME                  READY   STATUS    RESTARTS   AGE<br>pc-replicaset-cl82j   1/1     Running   0          75s<br>pc-replicaset-dslhb   1/1     Running   0          75s<br></code></pre></div></td></tr></table></figure><h2 id="2-Deployment（deploy）"><a href="#2-Deployment（deploy）" class="headerlink" title="2.Deployment（deploy）"></a>2.Deployment（deploy）</h2><p><strong>Deployment</strong>并不直接管理pod，而是通过管理<strong>ReplicaSet</strong>来间接管理Pod，即：<strong>Deployment</strong>管理<strong>ReplicaSet</strong>，<strong>ReplicaSet</strong>管理<strong>Pod</strong>，所以<strong>Deployment</strong>比<strong>ReplicaSet</strong>功能更加强大</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112161438627.png" alt="image-20211216143827793"></p><p>Deployment主要功能：</p><ul><li>支持ReplicaSet的所有功能</li><li>支持发布的停止、继续</li><li>支持滚动升级和回滚版本</li></ul><p>yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># 名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">deploy</span><br>    <br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 副本数量</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本个数</span><br>  <span class="hljs-attr">paused:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 暂停部署，默认是false</span><br>  <span class="hljs-attr">progressDeadlineSeconds:</span> <span class="hljs-number">600</span> <span class="hljs-comment"># 部署超时时间（s），默认是600</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 滚动更新</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">30</span><span class="hljs-string">%</span> <span class="hljs-comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>      <br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="创建deployment"><a href="#创建deployment" class="headerlink" title="创建deployment"></a>创建deployment</h3><p>创建pc-deployment.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span>      <br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建deployment</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl create -f pc-deployment.yaml</span> <br>deployment.apps/pc-deployment created<br><br><span class="hljs-meta">#</span><span class="bash"> 查看deployment</span><br><span class="hljs-meta">#</span><span class="bash"> UP-TO-DATE 最新版本的pod的数量</span><br><span class="hljs-meta">#</span><span class="bash"> AVAILABLE  当前可用的pod的数量</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get deploy -n njm</span><br>NAME            READY   UP-TO-DATE   AVAILABLE   AGE<br>pc-deployment   3/3     3            3           101s<br><br><span class="hljs-meta">#</span><span class="bash"> 查看pod</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get pod -n njm</span><br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-5d9c9b97bb-fs2cp   1/1     Running   0          3m<br>pc-deployment-5d9c9b97bb-kch8l   1/1     Running   0          3m<br>pc-deployment-5d9c9b97bb-rjns8   1/1     Running   0          3m<br></code></pre></div></td></tr></table></figure><h3 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h3><p>和rs差不多</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第一种 变更副本数量为5个</span><br>[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5  -n njm<br>deployment.apps/pc-deployment scaled<br><br><span class="hljs-meta">#</span><span class="bash"> 第二种 编辑deployment的副本数量，修改spec:replicas: 4</span><br>[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n dev<br>deployment.apps/pc-deployment edited<br></code></pre></div></td></tr></table></figure><h3 id="镜像更新"><a href="#镜像更新" class="headerlink" title="镜像更新"></a>镜像更新</h3><p>deployment支持两种更新策略:</p><ul><li>重建更新：一次性删掉所有旧版本pod，立即重建同等数量的新版本pod</li><li>滚动更新（默认）：先删一部分旧版本pod，再重建一部分新版本pod，以此类推</li></ul><p>可以通过<code>strategy</code>指定策略类型</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">strategy: 指定新的Pod替换旧的Pod的策略， 支持两个属性：<br>  type: 指定策略类型，支持两种策略<br><span class="hljs-code">    Recreate: 重建更新</span><br><span class="hljs-code">    RollingUpdate: 滚动更新中</span><br><span class="hljs-code">  rollingUpdate: 当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span><br><span class="hljs-code">    maxUnavailable: 用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span><br><span class="hljs-code">    maxSurge: 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span><br></code></pre></div></td></tr></table></figure><p><strong>重建更新</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><span class="hljs-comment">#策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><span class="hljs-comment">#重建更新</span><br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 变更镜像</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl <span class="hljs-built_in">set</span> image deployment pc-deployment nginx=nginx -n njm</span><br>deployment.apps/pc-deployment image updated<br><br><span class="hljs-meta">#</span><span class="bash">查看 正在停止</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get pod -n njm</span><br>NAME                             READY   STATUS     RESTARTS   AGE<br>pc-deployment-7cbfc8fc88-2cpnp   1/1     Terminating   0          63s<br>pc-deployment-7cbfc8fc88-gx4lq   1/1     Terminating   0          63s<br>pc-deployment-7cbfc8fc88-v2b9t   1/1     Terminating   0          63s<br><span class="hljs-meta">#</span><span class="bash">查看 正在创建</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get pod -n njm</span><br>NAME                             READY   STATUS              RESTARTS   AGE              <br>pc-deployment-7cbfc8fc88-2cpnp   0/1     ContainerCreating   0          2s <br>pc-deployment-7cbfc8fc88-gx4lq   0/1     ContainerCreating   0          2s  <br>pc-deployment-7cbfc8fc88-v2b9t   0/1     ContainerCreating   0          2s <br><span class="hljs-meta">#</span><span class="bash">查看 正在运行</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get pod -n njm</span><br>NAME                             READY   STATUS    RESTARTS   AGE<br>pc-deployment-7cbfc8fc88-2cpnp   1/1     Running   0          63s<br>pc-deployment-7cbfc8fc88-gx4lq   1/1     Running   0          63s<br>pc-deployment-7cbfc8fc88-v2b9t   1/1     Running   0          63s<br><br></code></pre></div></td></tr></table></figure><p><strong>滚动更新</strong></p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-comment"># 策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span> <br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span><br></code></pre></div></td></tr></table></figure><p>其他都一样</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在滚动更新中<strong>原来的rs依旧存在</strong>，只是pod数量变为了0，而后又新产生了一个rs，pod数量为3<br>这就是deployment能够进行版本回退的原因</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl get rs -n njm</span><br>NAME                       DESIRED   CURRENT   READY   AGE<br>pc-deployment-5d9c9b97bb   0         0         0       85s<br>pc-deployment-7cbfc8fc88   3         3         3       14s<br></code></pre></div></td></tr></table></figure><p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能</p><p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p><ul><li>status    显示当前升级状态</li><li>history   显示 升级历史记录</li><li>pause    暂停版本升级过程</li><li>resume   继续已经暂停的版本升级过程</li><li>restart    重启版本升级过程</li><li>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看当前升级版本的状态</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl rollout status deploy pc-deployment -n njm</span><br>deployment &quot;pc-deployment&quot; successfully rolled out<br><br><span class="hljs-meta">#</span><span class="bash"> 查看升级历史记录,有两个版本.CHANGE-CAUSE是因为在启动时没有加--record=<span class="hljs-literal">true</span>，所以没有记录</span><br><span class="hljs-meta">[root@k8s-master]#</span><span class="bash"> kubectl rollout <span class="hljs-built_in">history</span> deploy pc-deployment -n njm</span><br>deployment.apps/pc-deployment <br>REVISION  CHANGE-CAUSE<br>1         &lt;none&gt;<br>2         &lt;none&gt;<br></code></pre></div></td></tr></table></figure><p><strong>版本回退</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 这里直接使用--to-revision=1回滚到了1版本， 如果省略这个选项，默认回退到上个版本</span><br>[root@k8s-master ]# kubectl rollout undo deployment pc-deployment --to-revision=1 -n njm<br>deployment.apps/pc-deployment rolled back<br><br><span class="hljs-meta">#</span><span class="bash"> 查看rs 发现第一个rs中变成了有3个pod运行</span><br>[root@k8s-master ]# kubectl get rs -n njm<br>NAME                       DESIRED   CURRENT   READY   AGE<br>pc-deployment-5d9c9b97bb   3         3         3       12m<br>pc-deployment-7cbfc8fc88   0         0         0       10m<br></code></pre></div></td></tr></table></figure><p>其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</p><h2 id="3-DaemonSet-DS"><a href="#3-DaemonSet-DS" class="headerlink" title="3.DaemonSet(DS)"></a>3.DaemonSet(DS)</h2><p>DaemonSet控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。</p><p>也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112171645439.png" alt="image-20211217164517412"></p><p>DaemonSet控制器的特点：</p><ul><li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li><li>当节点从集群中移除时，Pod 也就被垃圾回收了</li></ul><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">daemonset</span><br>    <br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 保留历史版本</span><br>  <span class="hljs-attr">updateStrategy:</span> <span class="hljs-comment"># 更新策略</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span> <span class="hljs-comment"># 滚动更新策略</span><br>    <span class="hljs-attr">rollingUpdate:</span> <span class="hljs-comment"># 滚动更新</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-comment"># Labels匹配规则</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">matchExpressions:</span> <span class="hljs-comment"># Expressions匹配规则</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">nginx-pod</span>]&#125;<br>      <br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><h2 id="4-Job"><a href="#4-Job" class="headerlink" title="4.Job"></a>4.Job</h2><p>主要用于负责**批量处理(一次要处理指定数量任务)<strong>短暂的</strong>一次性(每个任务仅运行一次就结束)**任务</p><ul><li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li><li>当成功结束的pod达到指定的数量时，Job将完成执行</li></ul><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span> <span class="hljs-comment"># 版本号</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span> <span class="hljs-comment"># 类型       </span><br><span class="hljs-attr">metadata:</span> <span class="hljs-comment"># 元数据</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-comment"># rs名称 </span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-comment"># 所属命名空间 </span><br>  <span class="hljs-attr">labels:</span> <span class="hljs-comment">#标签</span><br>    <span class="hljs-attr">controller:</span> <span class="hljs-string">job</span><br>    <br><span class="hljs-attr">spec:</span> <span class="hljs-comment"># 详情描述</span><br>  <span class="hljs-attr">completions:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job需要成功运行Pods的次数。默认值: 1</span><br>  <span class="hljs-attr">parallelism:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span><br>  <span class="hljs-attr">activeDeadlineSeconds:</span> <span class="hljs-number">30</span> <span class="hljs-comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止</span><br>  <span class="hljs-attr">backoffLimit:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># 指定job失败后进行重试的次数。默认是6</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否可以使用selector选择器选择pod，默认是false</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 选择器，通过它指定该控制器管理哪些pod</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">matchExpressions:</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">app</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">counter-pod</span>]&#125;<br>      <br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span> <span class="hljs-comment"># 重启策略只能设置为Never或者OnFailure</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>restartPolicy重启策略：<br>    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变<br>    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</p><hr><p>创建job</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pc-job</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">manualSelector:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">counter-pod</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.30</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">pod在运行完毕任务后，就会变成Completed状态</span><br>[root@k8s-master ]# kubectl get pod -n njm<br>NAME           READY   STATUS    RESTARTS   AGE<br>pc-job-hh9fs   1/1     Running   0          7s<br><br>[root@k8s-master ]# kubectl get pod -n njm<br>NAME           READY   STATUS      RESTARTS   AGE<br>pc-job-hh9fs   0/1     Completed   0          35s<br></code></pre></div></td></tr></table></figure><h1 id="七、Service"><a href="#七、Service" class="headerlink" title="七、Service"></a>七、Service</h1><blockquote><p>每个Pod都会分配一个单独的Pod IP，但是该IP会随着Pod的重建而变化，且该IP为集群内部的虚拟IP，外部无法访问。因此kubernets设计了Service来解决这个问题</p></blockquote><p>​    <strong>Service</strong>会对提供同一个服务的多个pod进行聚合，并提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112091030050.png" alt="image-20211209103014124"></p><p>​    Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong></p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112171349232.png" alt="image-20211217134945154"></p><p>两种不同的service类型</p><p>ClusterIP ：Service 通过 Cluster 内部的 IP 对外提供服务，只有 Cluster 内的节点和 Pod 可访问，这是默认的 Service 类型</p><p>NodePort ：Service 通过 Cluster 节点的静态端口对外提供服务。Cluster 外部可以通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 访问 Service</p><h2 id="1-命令方式"><a href="#1-命令方式" class="headerlink" title="1.命令方式"></a>1.命令方式</h2><p><strong>操作一：创建集群内部可访问的Service</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Service通过deployment找到要管理的pod</span><br><span class="hljs-meta">#</span><span class="bash"> --name Service的名字</span><br><span class="hljs-meta">#</span><span class="bash"> --<span class="hljs-built_in">type</span> Serive的类型，ClusterIP指集群内部可访问</span><br><span class="hljs-meta">#</span><span class="bash"> --port Service的端口</span><br><span class="hljs-meta">#</span><span class="bash"> --target-port 目标的端口</span><br><span class="hljs-meta">#</span><span class="bash"> -n 命名空间</span><br>[root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev<br>service/svc-nginx1 exposed<br><br><span class="hljs-meta">#</span><span class="bash"> 查看service，svc是service的缩写</span><br><span class="hljs-meta">#</span><span class="bash"> 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span><br>[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wide<br>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR<br>svc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80/TCP    3m51s   run=nginx<br><br><span class="hljs-meta">#</span><span class="bash"> 访问，service会随机寻找一个</span><br>[root@master ~]# curl 10.109.179.231:80<br></code></pre></div></td></tr></table></figure><p><strong>操作二：创建集群外部可访问的Service</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改类型为NodePort</span><br>[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev<br><br><span class="hljs-meta">#</span><span class="bash"> 查看</span><br><span class="hljs-meta">#</span><span class="bash"> 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928）</span><br>[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wide<br>NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTOR<br>svc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928/TCP   9s     run=nginx<br><br><span class="hljs-meta">#</span><span class="bash"> 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了</span><br><span class="hljs-meta">#</span><span class="bash"> 电脑主机上通过浏览器访问下面的地址（master主机的地址）会跳转到service 10.100.94.0:80</span><br>http://192.168.90.100:31928/<br><br><span class="hljs-meta">#</span><span class="bash"> 删除service</span><br>[root@master ~]# kubectl delete svc svc-nginx-2 -n dev <br>service &quot;svc-nginx-1&quot; deleted<br></code></pre></div></td></tr></table></figure><hr><h2 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2.配置方式"></a><strong>2.配置方式</strong></h2><ol><li><p>首先创建一个deployment管理pod</p><p>创建了三个httpd的pod，端口为80</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br>  <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">httpd</span><br>      <br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">httpd</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">httpd</span><br>         <span class="hljs-attr">name:</span> <span class="hljs-string">httpd</span><br>         <span class="hljs-attr">ports:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></div></td></tr></table></figure><p>查看，三个pod的ip分别为.3、.4、.5</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master service-test]# kubectl get pod -n njm -o wide<br>NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE              <br>httpd-5dcdfd6b9f-mgzgp   1/1     Running   0          36m   172.29.16.3   192.168.70.28 <br>httpd-5dcdfd6b9f-ntr5x   1/1     Running   0          36m   172.29.16.4   192.168.70.28<br>httpd-5dcdfd6b9f-spf6n   1/1     Running   0          36m   172.29.16.5   192.168.70.28   <br></code></pre></div></td></tr></table></figure><ol start="2"><li>创建service</li></ol><p><code>nodePort</code>：（主机）节点的端口，省略的话随机分配</p><p><code>port</code>：service的端口</p><p><code>targetPort</code>：目标pod的端口</p><p><code>type</code>：service的类型</p><p><code>selector</code>：标签选择器，上一步<code>deploy</code>标签为<code>run: httpd</code>，这里对应</p><p><code>sessionAffinity</code>：session亲和性，支持ClientIP、None。比如三个pod位于A、B、C三个地区，对于来自A地区的请求要交给A地区的pod</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">httpd-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">njm</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.</span><span class="hljs-string">xx.xx.xx</span> <span class="hljs-comment"># service的ip 可省略</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-comment">#session亲和性</span><br></code></pre></div></td></tr></table></figure><p>查看</p><p><code>PORT(S)</code> 为 <code>80:58721 </code>，<code>80</code> 是 service的端口（即port），<code>58721</code> 则是主机（或者节点）上监听的端口。每个节点都会监听此端口并将请求转发给 Service</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master service-test]# kubectl get svc -n njm<br>NAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE<br>httpd-service   NodePort   10.253.12.26   &lt;none&gt;        80:58721/TCP   23m<br></code></pre></div></td></tr></table></figure><p>查看 httpd-svc 与 Pod 的对应关系</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master service-test]# kubectl describe service httpd-service -n njm<br>Name:                     httpd-service<br>Namespace:                njm<br>Labels:                   &lt;none&gt;<br>Annotations:              &lt;none&gt;<br>Selector:                 run=httpd<br>Type:                     NodePort<br>IP:                       10.253.12.26<br>Port:                     &lt;unset&gt;  80/TCP<br>TargetPort:               80/TCP<br>NodePort:                 &lt;unset&gt;  58721/TCP<br>Endpoints:                172.29.16.3:80,172.29.16.4:80,172.29.16.5:80<br>Session Affinity:         None<br>External Traffic Policy:  Cluster<br>Events:                   &lt;none&gt;<br></code></pre></div></td></tr></table></figure><ol start="3"><li>访问</li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过service的ip访问</span><br>[root@k8s-master ~]# curl 10.253.12.26:80<br>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br><br><span class="hljs-meta">#</span><span class="bash"> 通过主机的ip访问</span><br>[root@k8s-master ~]# curl 192.168.70.28:58721<br>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><h2 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3.工作原理"></a>3.工作原理</h2><p>使用<code>iptables-save | grep serviceIP</code>查看规则</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-master ~]# iptables-save | grep 10.253.12.26<br>-A KUBE-SERVICES ! -s 10.253.0.0/16 -d 10.253.12.26/32 -p tcp -m comment --comment &quot;njm/httpd-service cluster IP&quot; -m tcp --dport 80 -j KUBE-MARK-MASQ<br>-A KUBE-SERVICES -d 10.253.12.26/32 -p tcp -m comment --comment &quot;njm/httpd-service cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-6DSZY5JO37TTEYHN<br></code></pre></div></td></tr></table></figure><p>这两条规则的含义是：</p><ol><li>如果 Cluster 内的 Pod（源地址来自 10.253.0.0/16）要访问 <code>httpd-service</code>，则允许</li><li>其他源地址访问 <code>httpd-service</code>，跳转到规则<code>KUBE-SVC-6DSZY5JO37TTEYHN</code></li></ol><hr><p>查看<code>KUBE-SVC-6DSZY5JO37TTEYHN</code>规则</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112231453021.png" alt="image-20211223143306492"></p><p>这三条规则的含义是：</p><ol><li>1/3 的概率跳转到规则<code> KUBE-SEP-YZI6E5F46FBZHQJD</code></li><li>1/3 的概率（剩下 2/3 的一半）跳转到规则<code> KUBE-SEP-YZI6E5F46FBZHQJD</code></li><li>1/3 的概率跳转到规则 <code>KUBE-SEP-YXWZPGCWM5AYTRC5</code></li></ol><hr><p>查看第一条<code>KUBE-SEP-YZI6E5F46FBZHQJD</code>规则，最后会被转发到<code>172.29.16.3</code>的pod<code>80</code>端口上</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112231436062.png" alt="image-20211223143614670"></p><p>查看这三条规则，iptables 将访问 Service 的流量转发到后端 Pod，而且使用类似轮询的负载均衡策略</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202112231437094.png" alt="image-20211223143717405"></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/01/19/Docker/"/>
    <url>/2022/01/19/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-Docker是什么？"><a href="#1-Docker是什么？" class="headerlink" title="1.Docker是什么？"></a>1.Docker是什么？</h2><p>​    Docker是一种<strong>容器技术</strong>，就像虚拟机，在自己的电脑中模拟出一台或多台子电脑，“子电脑”和“子电脑”之间，是相互隔离的，互不影响。</p><p>​    容器技术，也是虚拟化技术，属于轻量级的虚拟化，因为虚拟机的占用空间更大，一般都需要几个G，启动也慢，而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，因为容器内的应用直接运行在宿主机的内核中，所以它启动时间很快，几秒钟就能完成。</p><h2 id="2-Docker可以做什么？"><a href="#2-Docker可以做什么？" class="headerlink" title="2.Docker可以做什么？"></a><strong>2.Docker可以做什么？</strong></h2><p>​        Docker可以让开发者构建应用程序时，将它与其依赖环境一起打包到一个<strong>容器</strong>中，然后很容易地发布和应用到任意平台中。</p><ul><li>可移植性：本地开发的项目想要放在服务器上，需要在服务器上再安装一次项目所依赖的环境，Docker将一整套环境封装成<strong>镜像</strong>，无需重复配置环境，解决运行环境不一致所导致的问题。这样就不会产生“本地运行没问题，可一到服务器上就不行了”的情况。</li><li>隔离：不同的项目所依赖的环境不一样，如果把他们依赖的软件都安装在一个服务器上，不仅安装时间长，而且可能会有冲突。Docker容器使应用程序不仅彼此隔离，而且与底层系统隔离。</li></ul><p>文档教程：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>中文文档：<a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a></p><p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="3-Docker的核心"><a href="#3-Docker的核心" class="headerlink" title="3.Docker的核心"></a>3.Docker的核心</h2><p>Docker有3大核心：镜像、容器、仓库</p><blockquote><p>Docker运行一个程序的过程： 去<strong>仓库</strong>把<strong>镜像</strong>拉到本地，然后用一条命令把镜像运行起来，变成<strong>容器</strong>。</p></blockquote><h3 id="镜像（Images）"><a href="#镜像（Images）" class="headerlink" title="镜像（Images）"></a>镜像（Images）</h3><p>​    镜像是一个特殊的文件系统。它除了<strong>提供容器</strong>运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>​    类似于Linux镜像文件（<strong>镜像</strong>），可以使用同一个镜像文件创建多个Linux系统（<strong>容器</strong>）。</p><p>​    比如有一个Tomcat<strong>镜像</strong>，镜像是不能启动的，要使用run命令变成<strong>容器</strong>，服务/项目运行就是在<strong>容器</strong>中，当然一个镜像可以创建多个容器。</p><pre><code class=" mermaid">graph LR;  Tomcat镜像--run--&gt;Tomcat01容器  Tomcat镜像--run--&gt;Tomcat02容器  Tomcat镜像--run--&gt;Tomcat03容器</code></pre><h3 id="容器（Containers）"><a href="#容器（Containers）" class="headerlink" title="容器（Containers）"></a>容器（Containers）</h3><p>容器是运行程序的地方，里面运行着我们指定的应用，通过镜像来创建的。</p><p>镜像=类，容器=实例</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h3><p>存放镜像的地方，和Git类似。</p><p>负责对Docker镜像进行管理的，最常用的Registry公开服务，是官方的Docker Hub，这也是默认的 Registry。阿里云等也都有自己的容器服务器，毕竟Docker是在国外的</p><h1 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h1><h2 id="1-环境查看"><a href="#1-环境查看" class="headerlink" title="1.环境查看"></a>1.环境查看</h2><p>不同的操作系统安装方式也不同，这里为ubuntu  <a href="https://www.runoob.com/docker/ubuntu-docker-install.html">https://www.runoob.com/docker/ubuntu-docker-install.html</a></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看系统架构</span><br>root:~# uname -a<br>Linux iZbp1aq6c9kbbexg9cxsqiZ 4.4.0-93-generic #116-Ubuntu SMP Fri Aug 11 21:17:51 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux<br><span class="hljs-meta">#</span><span class="bash">查看系统信息</span><br>root:~# lsb_release -a<br>LSB Version:    core-9.20160110ubuntu0.2-amd64:core-9.20160110ubuntu0.2-noarch:security-9.20160110ubuntu0.2-amd64:security-9.20160110ubuntu0.2-noarch<br>Distributor ID: Ubuntu<br>Description:    Ubuntu 16.04.3 LTS<br>Release:        16.04<br>Codename:       xenial<br></code></pre></div></td></tr></table></figure><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><h3 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a><strong>设置仓库</strong></h3><p>首次安装之前，需要设置 Docker 仓库。之后可以从仓库安装和更新Docker </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">1.更新源和安装apt 依赖包，用于通过HTTPS来获取仓库<br><span class="hljs-meta">#</span><span class="bash"> apt-get update</span><br><span class="hljs-meta">#</span><span class="bash"> apt-get install \</span><br><span class="bash">    ca-certificates \</span><br><span class="bash">    curl \</span><br><span class="bash">    gnupg \</span><br><span class="bash">    lsb-release</span><br>    <br>2.添加软件源的GPG密钥。这里采用中科大的<br>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><br>3.添加Docker软件源。同样中科大<br><span class="hljs-meta">#</span><span class="bash"> add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">1.再次更新源<br><span class="hljs-meta">#</span><span class="bash"> apt-get update</span><br><br>2.安装 docker-ce社区版<br><span class="hljs-meta">#</span><span class="bash"> apt-get install docker-ce docker-ce-cli containerd.io</span><br><br>3.验证是否安装成功<br><span class="hljs-meta">#</span><span class="bash"> docker run hello-world</span><br><br>4. 这个命令会下载一个hello-world镜像并运行在容器中，打印出以下信息则安装成功<br>root@iZbp1aq6c9kbbexg9cxsqiZ:~# docker run hello-world<br>Unable to find image &#x27;hello-world:latest&#x27; locally<br>latest: Pulling from library/hello-world<br>2db29710123e: Pull complete <br>Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685<br>Status: Downloaded newer image for hello-world:latest<br><br>Hello from Docker!<br>This message shows that your installation appears to be working correctly.<br><br>To generate this message, Docker took the following steps:<br> 1. The Docker client contacted the Docker daemon.<br> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.<br>    (amd64)<br> 3. The Docker daemon created a new container from that image which runs the<br>    executable that produces the output you are currently reading.<br> 4. The Docker daemon streamed that output to the Docker client, which sent it<br>    to your terminal.<br><br>To try something more ambitious, you can run an Ubuntu container with:<br><span class="hljs-meta"> $</span><span class="bash"> docker run -it ubuntu bash</span><br><br>Share images, automate workflows, and more with a free Docker ID:<br> https://hub.docker.com/<br><br>For more examples and ideas, visit:<br> https://docs.docker.com/get-started/<br></code></pre></div></td></tr></table></figure><h3 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">1.卸载依赖<br><span class="hljs-meta">#</span><span class="bash"> apt-get remove docker docker-engine docker.io containerd runc</span><br>2.删除镜像、容器、配置文件等内容：<br><span class="hljs-meta">#</span><span class="bash"> rm -rf /var/lib/docker</span><br></code></pre></div></td></tr></table></figure><h3 id="Run流程"><a href="#Run流程" class="headerlink" title="Run流程"></a>Run流程</h3><p>Docker首先会从本地查找这个镜像，找到的话直接运行；找不到就去仓库上查找，找到的话返回该镜像运行</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111212122293.png" alt="image-20211121212242352"></p><h1 id="三、Docker常用命令"><a href="#三、Docker常用命令" class="headerlink" title="三、Docker常用命令"></a>三、Docker常用命令</h1><h2 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker 命令 --help#显示某命令的帮助信息<br>docker version #显示docker的版本信息<br>docker info   #显示docker的系统、镜像、容器信息<br></code></pre></div></td></tr></table></figure><h2 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p><code>docker images</code></p><ul><li>REPOSITORY：仓库源</li><li>TAG：标签（版本）</li><li>IMAGE ID：镜像的ID</li><li>CREATED：镜像创建的时间</li><li>SIZE：大小</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker images</span><br>REPOSITORY    TAG       IMAGE ID       CREATED       SIZE<br>hello<span class="hljs-literal">-world</span>   latest    feb5d9fea6a5   <span class="hljs-number">8</span> weeks ago   <span class="hljs-number">13.3</span>kB<br></code></pre></div></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p><code>docker search</code></p><ul><li>NAME：镜像仓库源</li><li>DESCRIPTION： 镜像的描述</li><li>OFFICIAL：是否 docker 官方发布</li><li>STARS： 类似 Github 里面的 star</li><li>AUTOMATED： 自动构建</li></ul><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker search mysql</span><br>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                             MySQL is a widely used, <span class="hljs-built_in">open-source</span> relation…   <span class="hljs-number">11708</span>     [<span class="hljs-type">OK</span>]       <br>mariadb                           MariaDB Server is a high performing open sou…   <span class="hljs-number">4459</span>      [<span class="hljs-type">OK</span>]       <br>mysql/mysql<span class="hljs-literal">-server</span>                Optimized MySQL Server Docker images. Create…   <span class="hljs-number">870</span>                  [<span class="hljs-type">OK</span>]<br></code></pre></div></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p><code>docker pull</code></p><p>默认下载最新版，可以指定版本：docker pull 镜像名:tag</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment">#下载最新的</span><br>[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker pull mysql</span><br>[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker pull docker.io/librara/mysql:latest</span><br><br><span class="hljs-comment">#指定版本</span><br>[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker pull mysql:5.7</span><br></code></pre></div></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>docker rmi</code></p><p><code>rm</code>删除 + <code>i</code>镜像 = <code>rmi</code>删除镜像</p><p>可以根据镜像ID或名字来删</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker images</span><br>REPOSITORY    TAG       IMAGE ID       CREATED       SIZE<br>mysql         <span class="hljs-number">5.7</span>       <span class="hljs-number">8</span>b43c6af2ad0   <span class="hljs-number">4</span> days ago    <span class="hljs-number">448</span>MB<br>hello<span class="hljs-literal">-world</span>   latest    feb5d9fea6a5   <span class="hljs-number">8</span> weeks ago   <span class="hljs-number">13.3</span>kB<br>[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker rmi  8b43c6af2ad0 </span><br><br><span class="hljs-comment">#批量删除使用-f，后面的参数代表镜像ID，docker images -q展示出本地所有镜像的ID</span><br>[<span class="hljs-type">root</span>]<span class="hljs-comment"># docker rmi -f $(docker images -q)</span><br></code></pre></div></td></tr></table></figure><hr><h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><p><code>docker save 镜像ID/名 &gt; 打包后的文件名</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker save mycentos:1.0 &gt; mycentos.tar</span><br><span class="hljs-meta">[root]#</span><span class="bash"> ls</span><br>mycentos.tar<br></code></pre></div></td></tr></table></figure><h3 id="加载镜像"><a href="#加载镜像" class="headerlink" title="加载镜像"></a>加载镜像</h3><p><code>docker load &lt; 打包的文件</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">首先使用docker rmi mycentos:1.0删除镜像</span><br><span class="hljs-meta">[root]#</span><span class="bash"> docker rmi mycentos:1.0</span><br><span class="hljs-meta">[root]#</span><span class="bash"> docker load &lt; mycentos.tar</span> <br><br></code></pre></div></td></tr></table></figure><h2 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h2><p>容器是基于镜像的，所以要先下载一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">root@host:~# docker pull centos<br></code></pre></div></td></tr></table></figure><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p><code>docker run</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run [可选参数] image<br><br><span class="hljs-meta">#</span><span class="bash">参数</span><br>--name=&quot;Name&quot;容器名字，比如一个Tomcat镜像，启动多个就要给个名字区分<br>-d  后台运行<br>-it  使用交互式运行。-i交互式操作，-t终端<br>-p   容器端口，可与主机端口进行映射<br>-p ip:主机端口:容器端口<br>-p 主机端口:容器端口<br>-p 容器端口<br>-P大P，随机指定端口<br></code></pre></div></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动并进入容器，host为主机名</span><br>root@host:~# docker run -it centos bash<br><br><span class="hljs-meta">#</span><span class="bash">进入容器后主机名变为了caa2db760d6a，镜像的ID</span><br>[root@caa2db760d6a /]# <br></code></pre></div></td></tr></table></figure><p><strong>run命令的延伸：</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">--restart=always  #容器的自动启动（容器服务启动后容器自动，相当于开机自启动）<br>-h x.xx.xx       #设置容器主机名，相当于linux的hostname命令，不同的是-h是永久设置<br>--dns xx.xx.xx.xx  #设置容器使用的DNS服务器，因为容器也需要上网<br>--dns-search     #DNS搜索设置<br>--add-host hostname:IP  #注入hostname&lt;&gt;IP解析，相当于linux改host文件，加入--add-host www.baidu.com:127.0.0.1 当然也可以exec进去改<br>--rm           #服务停止时自动删除（容器停止后会自动删除）<br></code></pre></div></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">exit#容器停止并退出<br>Ctrl + P + Q#容器不停止（后台运行）并退出<br></code></pre></div></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p><code>docker ps</code></p><p>​    <code>-a</code>：查看正在运行的+历史运行过的容器</p><ul><li><p>CONTAINER ID：容器 ID</p></li><li><p>IMAGE：使用的镜像</p></li><li><p>COMMAND：启动容器时运行的命令</p></li><li><p>CREATED：容器的创建时间</p></li><li><p>STATUS：容器状态</p></li><li><p>PORTS：容器的端口信息和使用的连接类型（tcp\udp）</p></li><li><p>NAMES：容器名称</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">root@host:~# docker ps<br>root@host:~# docker ps -a<br>CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES<br>caa2db760d6a   centos         &quot;/bin/bash&quot;   5 minutes ago   Exited (0) 2 minutes ago             crazy_stonebraker<br>6e417c0d39ee   feb5d9fea6a5   &quot;/hello&quot;      19 hours ago    Exited (0) 19 hours ago              trusting_dhawan<br></code></pre></div></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">删除指定容器,不能删除正在运行的容器。强制删除使用rm -rf</span><br>docker rm 容器id<br><span class="hljs-meta">#</span><span class="bash">删除所有容器</span><br>docker rm -f $(docker ps -aq)<br></code></pre></div></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker start 容器id<br>docker restrat 容器id<br></code></pre></div></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker stop 容器id<br>docker kill 容器id#强制停止<br></code></pre></div></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><strong>查看容器日志</strong></p><p><code>-f</code>：展示日志输出</p><p><code>-t</code>：显示时间</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker logs -f -t --tail n 容器id<br></code></pre></div></td></tr></table></figure><p><strong>查看容器中进程信息</strong></p><p><code>docker top</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker top 容器id<br></code></pre></div></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><p><code>docker inspect </code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker inspect 镜像id<br></code></pre></div></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><ol><li><p><code>docker exec</code></p><p>进入容器后开启一个新的终端</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it 容器id /bin/bash<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p><code>docker attach</code> </p><p>进入容器正在执行的终端</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker attach 容器id<br></code></pre></div></td></tr></table></figure><p><strong>将容器内文件拷贝到主机</strong></p><p><code>docker cp</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker cp 容器id:容器内路径 目的主机路径<br></code></pre></div></td></tr></table></figure><p><strong>提交自己的镜像</strong></p><p><code>docker commit</code> 提交容器成为一个新的镜像，和git类似</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[tag]<br></code></pre></div></td></tr></table></figure><p>镜像是分层的文件，镜像运行就是容器增加了一层，而这一层是可更改的(镜像不可更改)，提交=将镜像原本的层+容器层打包成一个新的镜像</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241521345.png" alt="image-20211124152101069"></p><p>Tomcat9.0镜像层文件：</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231417663.png" alt="image-20211123141708366"></p><p>Tomcat9.0镜像运行后修改webapps中的文件，进行commit成新的镜像Tomcat:v2。多了一层</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231419643.png" alt="image-20211123141914653"></p><h1 id="四、数据卷"><a href="#四、数据卷" class="headerlink" title="四、数据卷"></a>四、数据卷</h1><p>我们将一个项目和运行环境(JDK、Tomcat、MySQL)放在容器中运行，如果容器删了，那么容器中的数据全都会丢失(删库跑路)，所以不能将MySQL数据存储在容器中</p><p><strong>数据卷</strong>：Docker容器的数据同步到本地（目录的挂载，将容器中目录挂载到本地目录）</p><p>容器间也可以数据共享，称为<strong>数据卷容器</strong></p><h2 id="1-指定路径挂载"><a href="#1-指定路径挂载" class="headerlink" title="1.指定路径挂载"></a>1.指定路径挂载</h2><p><strong>使用命令来挂载 <code>-v</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run -v 主机目录:容器目录<br></code></pre></div></td></tr></table></figure><p>Tomcat默认访问页面目录为 webapps/ROOT，将该目录映射到主机目录，主机目录中有index.html</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231548594.png" alt="image-20211123154846373"></p><p><code>-P</code>：映射随机端口</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -v /data/niujiaming:/usr/<span class="hljs-built_in">local</span>/tomcat/webapps/ROOT -P --name=<span class="hljs-string">&quot;tomcat06&quot;</span> tomcat:v2</span><br></code></pre></div></td></tr></table></figure><p><code>docker inspect</code>找到Mounts这一块，已经挂载成功</p><ul><li><code>Source</code>：主机内地址</li><li><code>Destination</code>：容器内地址</li></ul><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231551900.png"></p><p><code>docker ps</code>看到端口为49153</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root@k8s-node-201]#</span><span class="bash"> docker ps</span><br>CONTAINER ID   IMAGE       COMMAND            CREATED         STATUS         PORTS                     NAMES<br>27b4a04e5f89   tomcat:v2   &quot;catalina.sh run&quot;  8 minutes ago   Up 8 minutes   0.0.0.0:49153-&gt;8080/tcp   tomcat06<br></code></pre></div></td></tr></table></figure><p>访问该地址</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231547461.png"></p><h2 id="2-匿名挂载"><a href="#2-匿名挂载" class="headerlink" title="2.匿名挂载"></a><strong>2.匿名挂载</strong></h2><p><code>-v</code>后面只指定容器目录</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -v /usr/local/tomcat tomcat:<span class="hljs-number">9</span>.<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><h2 id="3-具名挂载"><a href="#3-具名挂载" class="headerlink" title="3.具名挂载"></a>3.具名挂载</h2><p><code>-v</code>后面指定一个<strong>卷名</strong>和容器目录</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run -d -P --name tomcat07 -v juming:/usr/local/tomcat tomcat:9.0<br></code></pre></div></td></tr></table></figure><p><strong>查看所有挂载信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker volume ls</span><br>DRIVER    VOLUME NAME<br>local     juming<br></code></pre></div></td></tr></table></figure><p><strong>查看卷名挂载信息</strong><br>docker容器内的卷，没有指定主机目录的话都是在 /var/lib/docker/volumes 这个目录下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker inspect juming</span><br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2021-11-23T16:59:53+08:00&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: null,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming/_data&quot;,<br>        &quot;Name&quot;: &quot;juming&quot;,<br>        &quot;Options&quot;: null,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br></code></pre></div></td></tr></table></figure><p>进入主机的 <code>/var/lib/docker/volumes/juming/_data</code>目录下，该目录的文件就是容器目录/usr/local/tomcat</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111231707586.png" alt="image-20211123170712573"></p><h1 id="五、数据卷容器"><a href="#五、数据卷容器" class="headerlink" title="五、数据卷容器"></a>五、数据卷容器</h1><p>容器之间配置信息的传递</p><ol><li><p><strong>创建父容器</strong> <strong>ngnix01</strong></p><p>匿名挂载，数据卷为/usr/share/nginx/html</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -p 9555:80 --name=<span class="hljs-string">&quot;nginx01&quot;</span> -v /usr/share/nginx/html nginx</span><br></code></pre></div></td></tr></table></figure><p>修改index.html文件内容</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">root@7ac95a402565:/usr/share/nginx/html# echo &#x27;this is nginx01 container&#x27;&gt;index.html<br>root@7ac95a402565:/usr/share/nginx/html# cat index.html <br>this is nginx01 container<br></code></pre></div></td></tr></table></figure></li><li><p><strong>创建子容器</strong> <strong>nginx02</strong></p><p><code>--volumes-from</code>：指定父容器的数据卷，这样nginx02的/usr/share/nginx/html指向nginx01的/usr/share/nginx/html</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -p 9556:80 --name=<span class="hljs-string">&quot;nginx02&quot;</span> --volumes-from nginx01 nginx</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>访问</strong></p><p>nginx01端口、nginx02端口</p></li></ol><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241151648.png" alt="image-20211124115143577"></p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241152943.png" alt="image-20211124115226038"></p><p>查看nginx01容器的数据卷</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241158890.png" alt="image-20211124115802674"></p><p>查看nginx02容器的数据卷</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241158152.png" alt="image-20211124115850270"></p><p>它们两个都指向了主机的目录</p><h1 id="六、Dockerfile"><a href="#六、Dockerfile" class="headerlink" title="六、Dockerfile"></a>六、Dockerfile</h1><p>用来构建docker镜像的的构建文件（脚本）</p><p>镜像是一层层的文件，而Dockerfile中每个命令都是一层</p><h2 id="1-创建Dockerfile"><a href="#1-创建Dockerfile" class="headerlink" title="1.创建Dockerfile"></a>1.创建Dockerfile</h2><p><code>FROM</code>：定制需要的基础镜像</p><p><code>VOLUME</code>：定义匿名数据卷，镜像中会有volume01、volume02文件夹，如果在<code>run</code>的时候没有挂载数据卷，会自动挂载到匿名卷</p><p><code>RUN</code>：用于执行后面跟着的命令行命令</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> vim dockerfile01</span><br><span class="hljs-meta">[root]#</span><span class="bash"> cat dockerfile01</span> <br>FROM nginx<br>VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]<br>RUN echo &#x27;this is nginx image&#x27; &gt; /usr/share/nginx/html/index.html<br></code></pre></div></td></tr></table></figure><h2 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2.构建镜像"></a>2.构建镜像</h2><p> <strong><code>docker build</code></strong></p><p><code>-f</code>：指定文件，Docker默认指定的文件名称为<code>Dockerfile</code>，如果构建文件叫这个名字，就不需要-f</p><p><code>-t</code>：镜像的名字和tag</p><p><code>.</code>：上下文路径，指docker在构建镜像时，如想要使用到本机的文件，docker build 命令得知这个路径后，会将路径下的所有内容打包。构建过程实际是由docker引擎来完成的，所以无法使用本机文件，需要将上下文路径下的文件一起打包给docker引擎使用，默认为 Dockerfile 所在的位置 （不要放无用的文件，会一起打包的，如果文件过多会造成过程缓慢）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker build -f dockerfile01 -t niujiaming/nginx:1.0 .</span><br>Sending build context to Docker daemon  3.072kB<br>Step 1/2 : FROM nginx<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 4f380adfc10f</span><br>Step 2/2 : RUN echo &#x27;this is nginx image&#x27; &gt; /usr/share/nginx/html/index.html<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 95bd82f5c70d</span><br>Removing intermediate container 95bd82f5c70d<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> f6838b1e004f</span><br>Successfully built f6838b1e004f<br>Successfully tagged niujiaming/nginx:1.0<br></code></pre></div></td></tr></table></figure><p><strong>查看构建的镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker images</span><br>REPOSITORY         TAG              IMAGE ID       CREATED         SIZE<br>niujiaming/nginx   1.0              f6838b1e004f   7 minutes ago   133MB<br></code></pre></div></td></tr></table></figure><h2 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3.运行镜像"></a>3.运行镜像</h2><p>Dockerfile没有指定数据卷，run也没有指定数据卷，所以是匿名挂载</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -P  niujiaming/nginx:1.0</span><br></code></pre></div></td></tr></table></figure><p><strong>查看容器信息</strong></p><p><code>docker inspect 容器id</code></p><p>Mounts有数据卷信息</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111241035631.png"></p><h2 id="Dockfile指令"><a href="#Dockfile指令" class="headerlink" title="Dockfile指令"></a>Dockfile指令</h2><p>规则：</p><ol><li>每个指令都必须是大写字母</li><li>执行从上到下执行</li><li>#表示注释</li><li>每个指令都会创建提交一个新的镜像层</li></ol><table><thead><tr><th>指令</th><th align="left">描述</th><th>语法</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td align="left">指定基础镜像，并且必须是第一条指令</td><td>FROM &lt; image&gt;[:&lt; tag&gt;]</td></tr><tr><td>MAINTAINER</td><td align="left">设置镜像作者</td><td>MAINTAINER &lt; name&gt;</td></tr><tr><td>LABEL</td><td align="left">为镜像指定标签</td><td>LABEL &lt; key&gt;=&lt; value&gt;</td></tr><tr><td><strong>RUN</strong></td><td align="left">镜像构建 <code>docker build</code> 时执行的命令</td><td>RUN &lt; command&gt; | RUN [“executeable”, “param1”]</td></tr><tr><td><strong>CMD</strong></td><td align="left">镜像运行 <code>docker run</code> 时执行的命令。如果写了多条则只有最后一条生效。如果在<code>docker run</code>时添加命令，则会替换CMD设置的命令</td><td>同上👆</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td align="left">类似于 CMD 指令，但不会被docker run命令覆盖，而是将命令当作字符串，传递给ENTRYPOINT作为参数。例：ENTRYPOINT [“ls”,”-a”] ，docker run -l，最后执行的是ls -la</td><td>ENTRYPOINT [“&lt; executeable&gt;”,”&lt; param1&gt;”]</td></tr><tr><td>ADD</td><td align="left">复制文件到镜像中。如果是压缩文件，add会自动解压。默认编译目录（上下文路径）寻找文件，dest为镜像中的绝对路径或者相对于<strong>WORKDIR</strong>的路径</td><td>ADD &lt; src&gt;… &lt; dest&gt;</td></tr><tr><td><strong>COPY</strong></td><td align="left">复制文件到镜像中。指令和ADD相似</td><td>同上👆</td></tr><tr><td><strong>WORKDIR</strong></td><td align="left">镜像的工作目录</td><td>WORKDIR &lt; Path&gt;</td></tr><tr><td><strong>VOLUME</strong></td><td align="left">定义匿名数据卷。启动容器时，会新建挂载点，并用镜像中的数据初始化挂载点，可以将主机目录或数据卷容器挂载到这里</td><td>VOLUME [“/dir”]</td></tr><tr><td><strong>EXPOSE</strong></td><td align="left">暴露镜像端口。但需要启动容器时使用-P/-p映射端口，才能通过外部访问容器提供的服务</td><td>EXPOSE &lt; port&gt; &lt; port&gt; …</td></tr><tr><td>ONBUILD</td><td align="left">后面跟的是其它指令，比如 RUN、COPY 等，这些指令在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行</td><td>ONBUILD [INSTRUCTION]</td></tr><tr><td>ENV</td><td align="left">设置镜像中的环境变量。后续的指令，就可以使用这个环境变量$key</td><td>ENV &lt; key&gt;=&lt; value&gt;…</td></tr><tr><td>ARG</td><td align="left">构建参数，作用同ENV，但ARG 的环境变量仅对 Dockerfile 内有效</td><td>ARG &lt; key&gt;[=&lt; value&gt;]</td></tr></tbody></table><h2 id="一些练习"><a href="#一些练习" class="headerlink" title="一些练习"></a>一些练习</h2><p>1.centos</p><p><strong>创建dockerfile-centos</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">[root]<span class="hljs-comment"># cat dockerfile-centos</span><br><span class="hljs-comment">#镜像源</span><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-comment">#标签 设置作者</span><br><span class="hljs-keyword">LABEL</span><span class="bash"> author=niujiaming</span><br><span class="hljs-comment">#定义环境变量</span><br><span class="hljs-keyword">ENV</span> MYPATH=/usr/local<br><span class="hljs-comment">#定义工作路径，为环境变量MYPATH</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-comment">#构建时安装vim等常用命令,每个run都会创建一层，\ 可换行，&amp;&amp; 连接</span><br><span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim \</span><br><span class="bash">   &amp;&amp; yum -y install net-tools</span><br><span class="hljs-comment">#运行时输出的信息</span><br><span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;---end---&quot;</span></span><br></code></pre></div></td></tr></table></figure><p><strong>构建</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker build -f dockerfile-centos -t mycentos:1.0 .</span><br></code></pre></div></td></tr></table></figure><p><strong>运行</strong> 也可以将<code>/bin/bash</code>作为CMD命令放在构建文件中</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">因为docker run 的命令为/bin/bash,覆盖了CMD <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;---end---&quot;</span>，所以没有输出</span><br><span class="hljs-meta">[root]#</span><span class="bash"> docker run -it mycentos:1.0 /bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">工作目录</span><br>[root@94ce9a8571ab local]# pwd<br>/usr/local<br></code></pre></div></td></tr></table></figure><p>2.tomcat</p><p><strong>下载tomcat、jdk压缩包</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.54/bin/apache-tomcat-9.0.54.tar.gz</span> <br><span class="hljs-meta">[root]#</span><span class="bash"> wget https://repo.huaweicloud.com/java/jdk/8u192-b12/jdk-8u192-linux-x64.tar.gz</span><br></code></pre></div></td></tr></table></figure><p><strong>编写Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#镜像源</span><br><span class="hljs-keyword">FROM</span> centos<br><span class="hljs-comment">#添加jdk和tomcat,ADD会自动解压</span><br><span class="hljs-keyword">ADD</span><span class="bash"> jdk-8u192-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/</span><br><span class="hljs-keyword">ADD</span><span class="bash"> apache-tomcat-9.0.54.tar.gz /usr/<span class="hljs-built_in">local</span>/</span><br><span class="hljs-comment">#安装vim</span><br><span class="hljs-keyword">RUN</span><span class="bash"> yum -y install vim</span><br><span class="hljs-comment">#设置环境变量</span><br><span class="hljs-keyword">ENV</span> MYPATH=/usr/local<br><span class="hljs-comment">#设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$MYPATH</span></span><br><span class="hljs-comment">#添加jdk、tomcat环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=/usr/local/jdk1.<span class="hljs-number">8.0</span>_192 CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar CATALINA_HOME=/usr/local/apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">54</span> CATALINA_BASH=$CATALINA_HOME PATH=$PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin<br><span class="hljs-comment">#暴露8080端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-comment">#启动Tomcat</span><br><span class="hljs-keyword">CMD</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.54/bin/startup.sh &amp;&amp; tail -F =/usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.54/bin/logs/catalina.out</span><br></code></pre></div></td></tr></table></figure><p><strong>构建</strong></p><p>因为构建文件名称为<code>Dockerfile</code>，这里不需要指定</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker build -t mytomcat:1.0 .</span><br></code></pre></div></td></tr></table></figure><p><strong>启动</strong></p><p>这里将webapps作为数据卷，/data/niujiaming下有index.html</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d  -p 9556:8080 --name mytomcat04 -v /data/niujiaming:/usr/<span class="hljs-built_in">local</span>/apache-tomcat-9.0.54/webapps mytomcat:1.0</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111251339421.png" alt="image-20211125133930622"></p><h2 id="Docker全流程图"><a href="#Docker全流程图" class="headerlink" title="Docker全流程图"></a>Docker全流程图</h2><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.itdaan.com%2Fi%2F815ca090f9f8f6360ec657afbe5118b41.jpg&refer=http%3A%2F%2Fwww.itdaan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640413330&t=e0af40cacbfd63eeef27df3b17e1de9c"></p><h1 id="七、Docker网络"><a href="#七、Docker网络" class="headerlink" title="七、Docker网络"></a>七、Docker网络</h1><h2 id="1-Docker0"><a href="#1-Docker0" class="headerlink" title="1.Docker0"></a>1.Docker0</h2><p>使用<code>ip addr</code>命令查看网卡</p><p>docker0就是docker的地址。docker使用的是桥接模式，使用的技术是veth-pair技术</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:63:5e:e7:d2 brd ff:ff:ff:ff:ff:ff<br>    inet 172.29.42.1/24 brd 172.29.42.255 scope global docker0<br>       valid_lft forever preferred_lft forever<br></code></pre></div></td></tr></table></figure><p>启动一个容器并查看它的网卡，有一个<code>80: eth0@if81</code>，为172.29.42.2</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it 529ca5d42ba3 ip addr</span><br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>80: eth0@if81: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:ac:1d:2a:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 172.29.42.2/24 brd 172.29.42.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br></code></pre></div></td></tr></table></figure><p>主机也会增加一个网卡<code>81: veth702c876@if80</code>，这里的80指的就是容器的网卡<code>80: eth0@if81</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">81: veth702c876@if80: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default <br>    link/ether 8a:96:ba:26:6d:97 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br></code></pre></div></td></tr></table></figure><p>主机网卡<code>81: veth702c876@if80</code></p><p>容器网卡<code>80: eth0@if81</code></p><p>这就是前面说的veth-pair（Virtual Ethernet）技术。veth-pair就是一对虚拟设备接口，它们都是成对出现的，一端连着协议，一端彼此相连，所以可以通信。veth-pair可以充当一个桥梁。</p><p>查看docker网络配置</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker network ls</span><br>NETWORK ID     NAME              DRIVER    SCOPE<br>0701b7e4eba0   bridge            bridge    local<br></code></pre></div></td></tr></table></figure><p>查看桥接 0701b7e4eba0</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker network inspect 0701b7e4eba0</span><br></code></pre></div></td></tr></table></figure><p>Docker0地址</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111251709208.png" alt="image-20211125170905239"></p><p>容器地址。启动容器时docker分配的ip</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111251710891.png" alt="image-20211125171042963"></p><p>主机上启动的Docker容器会连接到这个Docker0虚拟网桥上,这样主机上的所有容器就通过交换机连在了一个二层网络中</p><pre><code class=" mermaid">graph TB;  主机host--&gt;Docker0&#x2F;172.29.42.1;   Docker0&#x2F;172.29.42.1--veth-eth0--&gt;容器1&#x2F;172.29.42.2;    Docker0&#x2F;172.29.42.1--veth-eth0--&gt;容器2&#x2F;172.29.42.3;</code></pre><h2 id="2-自定义网络"><a href="#2-自定义网络" class="headerlink" title="2.自定义网络"></a>2.自定义网络</h2><blockquote><p> 自定义网络来控制哪些容器可以相互通信</p></blockquote><p><code>docker network ls</code></p><p>查看所有网络</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker network ls</span><br>NETWORK ID     NAME              DRIVER    SCOPE<br>0701b7e4eba0   bridge            bridge    local<br>e95169f22189   host              host      local<br>6aab19df3032   none              null      local<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>bridge</td><td>桥接。此模式会为每一个容器分配IP，并将容器连接到docker0虚拟网桥，</td></tr><tr><td>host</td><td>使用主机地址</td></tr><tr><td>none</td><td>关闭了容器的网络功能</td></tr><tr><td>自定义网络</td><td></td></tr></tbody></table><p>这3个网络是docker内置的，当我们运行一个容器需要指定网络时，可以通过<code>--net</code>参数来指定容器连接的网络。默认运行已经添加了<code>--net bridge</code></p><h3 id="1-创建一个网络"><a href="#1-创建一个网络" class="headerlink" title="1.创建一个网络"></a>1.<strong>创建一个网络</strong></h3><p><code>docker network create  [参数] 网络名</code> </p><ul><li><p><code>-d</code> / <code>--driver</code>：驱动程序管理网络，默认为bridge</p></li><li><p><code>--subnet</code>：子网</p></li><li><p><code>--gateway</code>：网关</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash">  docker network create -d bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 网络名</span><br></code></pre></div></td></tr></table></figure><p>查看</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">[root@k8s-node-201 ~]# docker network ls<br>NETWORK ID     NAME              DRIVER    SCOPE<br>0701b7e4eba0   bridge            bridge    local<br>e95169f22189   host              host      local<br>6aab19df3032   none              null      local<br>4b40a9e01c65   testnet           bridge    local<br></code></pre></div></td></tr></table></figure><p><code>ip addr</code>也会增加一个网络</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111261404086.png" alt="image-20211126140359910"></p><h3 id="2-启动容器，指定网络"><a href="#2-启动容器，指定网络" class="headerlink" title="2.启动容器，指定网络"></a><strong>2.启动容器，指定网络</strong></h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -P --name=<span class="hljs-string">&quot;mytomcat05&quot;</span> --net testnet  mytomcat:1.0</span><br><span class="hljs-meta">[root]#</span><span class="bash"> docker run -d -P --name=<span class="hljs-string">&quot;mytomcat06&quot;</span> --net testnet  mytomcat:1.0</span><br></code></pre></div></td></tr></table></figure><p><code>docker network inspect testnet</code></p><p>可以看到这两个容器</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111261411230.png" alt="image-20211126141145230"></p><p>通过自定义网络可以实现两个容器之间网络的互通</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it mytomcat05 ping 192.168.0.3</span><br>PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.<br>64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.128 ms<br><span class="hljs-meta">[root]#</span><span class="bash"> docker <span class="hljs-built_in">exec</span> -it mytomcat06 ping 192.168.0.2</span><br>PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.<br>64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.083 ms<br></code></pre></div></td></tr></table></figure><h3 id="3连接容器至网络"><a href="#3连接容器至网络" class="headerlink" title="3连接容器至网络"></a>3连接容器至网络</h3><p>mytomcat05、mytomcat06位于192.168.0.0/16网段中</p><p>mytomcat01位于Docker0（172.29.42.0/24）网段中</p><p>那么怎么让01访问05、06（将<strong>mytomcat01</strong>容器连接到<strong>testnet</strong>网络中）</p><p><code>docker network connect  网络名 容器名</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker network connect testnet mytomcat01<br></code></pre></div></td></tr></table></figure><p>查看<code>docker network inspect testnet</code></p><p>mytomcat01容器被加到testnet网络中了（相当于用一根网线把一台机器接入另一个局域网中）</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111261553090.png" alt="image-20211126155347907"></p><h1 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker Compose"></a>八、Docker Compose</h1><p>定义和运行<strong>多个</strong> Docker容器的应用，负责实现对Docker容器集群的快速编排</p><p>使用一个Dockerfile文件，可以定义一个单独的应用容器，但是有时需要多个容器相互配合来完成某项任务，例如要实现Web项目，需要Web服务容器，还要数据库容器、负载均衡容器等</p><p>compose满足了这样的需求，用户通过一个单独的<code>docker-compose.yml </code>模板文件来定义一组相关联的应用容器为一个项目(<strong>project</strong>)</p><p>核心概念：</p><ul><li><strong>服务（service）</strong>：一个应用的容器，比如web、redis、mysql，服务=容器，一堆容器组成一个项目</li><li><strong>项目（project）</strong>：多个服务共同组成的完整业务单元。在<code>docker-compose.yml</code>中定义，定义项目中用到的所有服务</li></ul><p><code>docker-compose.yml</code> </p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">.:/code</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">logvolume01:/var/log</span><br>    <span class="hljs-attr">links:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">logvolume01:</span> &#123;&#125;<br></code></pre></div></td></tr></table></figure><h2 id="1-安装Compose"><a href="#1-安装Compose" class="headerlink" title="1.安装Compose"></a>1.安装Compose</h2><p>下载二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose</span><br></code></pre></div></td></tr></table></figure><p>2.授权</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose</span><br></code></pre></div></td></tr></table></figure><p>3.测试</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker-compose version</span><br>docker-compose version 1.18.0, build 8dd22a9<br>docker-py version: 2.6.1<br>CPython version: 3.6.8<br>OpenSSL version: OpenSSL 1.0.2k-fips  26 Jan 2017<br></code></pre></div></td></tr></table></figure><h2 id="2-使用Compose"><a href="#2-使用Compose" class="headerlink" title="2.使用Compose"></a>2.使用Compose</h2><ol><li><p><code>docker-compose.yml</code>   定义应用所需要的环境(web、redis)</p><ul><li>version：版本</li><li>services：服务，可包含多个<ul><li>服务名（要唯一）<ul><li>image：创建当前这个服务使用的镜像</li><li>ports：端口映射，注意格式</li></ul></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9555:8080&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>运行docker-compose</p><p><code>docker-compose up</code>启动这个项目的所有服务。默认前台启动</p><ul><li><code>-d</code>：后台执行</li></ul></li><li><p><code>docker ps -a</code>查看</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker ps -a</span><br>CONTAINER ID   IMAGE        COMMAND            CREATED         STATUSPORTSNAMES<br>5c9ed5cbd86d   tomcat:8.0   &quot;catalina.sh run&quot;  3 minutes ago   Exited (143) 2 minutes agocomposetest_tomcat_1<br></code></pre></div></td></tr></table></figure><p>也会创建一个相应的网络，yml中所有的服务都位于该网络下</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">[root]#</span><span class="bash"> docker network ls</span><br>NETWORK ID     NAME                  DRIVER    SCOPE<br>101dbead5e52   composetest_default   bridge    local<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="3-yml模板命令"><a href="#3-yml模板命令" class="headerlink" title="3.yml模板命令"></a>3.yml模板命令</h2><p>标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a><strong>version</strong></h3><p>版本号</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定服务的镜像名称.。想当于run image</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>服务除了可以基于指定的镜像，还可以基于Dockerfile</p><p> compose会根据<code>build</code>中的Dockerfile自动构建镜像，然后使用镜像启动服务</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-comment">#相对路径，指定为从上下文路径 ./dir/Dockerfile</span><br>  <span class="hljs-attr">webapp01:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./dir</span><br>  <span class="hljs-comment">#使用dockerfile文件来构建，必须指定构建路径</span><br>  <span class="hljs-attr">webapp02:</span><br>    <span class="hljs-attr">build:</span><br>  <span class="hljs-attr">context:</span> <span class="hljs-string">./dir</span><br>  <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile02</span><br></code></pre></div></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>Compose的容器默认名称格式是：项目名称_ 服务名称_序号</p><p>自定义容器名称。相当于run –name</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat01:</span><br>  <span class="hljs-attr">container_name:</span> <span class="hljs-string">tomcat01</span> <br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>映射端口。相当于run -p</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br>    <span class="hljs-attr">ports:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9555:8080&quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>完成主机与容器目录数据卷共享。相当于run -v</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br>    <span class="hljs-attr">volumes:</span> <br>     <span class="hljs-comment">#只指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/tomcat/webapps</span><br>   <span class="hljs-comment">#使用绝对路径挂载数据卷</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/data:/usr/local/tomcat/webapps</span><br>     <span class="hljs-comment">#已经存在的命名的数据卷。datavolume必须存在，引用顶级 volumes 下的条目</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">datavolume:/var/lib/conf</span><br>   <br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">datavolume:</span> <span class="hljs-comment">#声明指定的卷名(最后生成的卷名为：项目名_卷名)</span><br></code></pre></div></td></tr></table></figure><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>配置容器连接的网络，需引用顶级 networks 下的条目。相当于run –net</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat01:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br>    <span class="hljs-comment">#当前服务使用哪个网络桥</span><br><span class="hljs-attr">networks:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-string">net01</span><br>  <span class="hljs-attr">tomcat02:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br><span class="hljs-attr">networks:</span> <br> <span class="hljs-bullet">-</span> <span class="hljs-string">net01</span><br><span class="hljs-comment">#定义服务用到的桥 </span><br><span class="hljs-attr">networks:</span> <br>  <span class="hljs-attr">net01:</span><span class="hljs-comment">#默认bridge模式</span><br></code></pre></div></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器 启动后默认执行的命令</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">tomcat01:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;tomcat:8.0&quot;</span><br><span class="hljs-attr">command:</span> <span class="hljs-string">&quot;/usr/local/tomcat/bin/startup.sh &quot;</span><br></code></pre></div></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>添加环境变量，可以用数组或字典两种方式</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql01:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;mysql:5.7&quot;</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql01</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">mysqldata:/var/lib/mysql</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">mysqlconf:/etc/mysql</span><br>    <span class="hljs-attr">environment:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=123456</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">SHOW=true</span><br>     <br>    <span class="hljs-comment"># 字典方式的布尔型要加引号</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-string">MYSQL_ROOT_PASSWORD:123456</span><br>      <span class="hljs-string">SHOW:&quot;true&quot;</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">mysqldata:</span><br>  <span class="hljs-attr">mysqlconf:</span><br></code></pre></div></td></tr></table></figure><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</p><p>如果通过<code>docker-compose -f 文件名</code>来指定yml模板文件的话，<code>env_file</code>变量的路径会基于模板文件的路径</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">services:<br>  mysql01:<br>    image: &quot;mysql:5.7&quot;<br>    container_name: mysql01<br>    ports:<br>     - &quot;3306:3306&quot;<br>    environment:<br>     - ./mysql.env<br></code></pre></div></td></tr></table></figure><p>环境变量文件格式，类似properties</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">MYSQL_ROOT_PASSWORD</span>=<span class="hljs-string">123456</span><br></code></pre></div></td></tr></table></figure><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>设置依赖关系，写的是<strong>服务名</strong></p><p>web服务依赖于mysql和redis，所以要先启动mysql和redis</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span> <br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">depends_on:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-string">image:redis</span><br>   <span class="hljs-attr">mysql:</span><br>     <span class="hljs-string">image:mysql:5.7</span><br></code></pre></div></td></tr></table></figure><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>通过命令检查容器(服务)是否健康运行</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>,<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-f&quot;</span>,<span class="hljs-string">&quot;http://localhost&quot;</span>]<span class="hljs-comment"># 设置检测程序</span><br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">1m30s</span><span class="hljs-comment"># 设置检测间隔</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span><span class="hljs-comment"># 设置检测超时时间</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 设置重试次数</span><br></code></pre></div></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>配置容器内核参数，可以使用数组或字典格式</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-attr">net.core.somaxconn:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">net.ipv4.tcp_syncookies:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.core.somaxconn=1024</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.ipv4.tcp_syncookies=0</span><br></code></pre></div></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>修改容器内系统的最大进程数</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">ulimits:</span><br>  <span class="hljs-attr">nproc:</span> <span class="hljs-number">65535</span><br>  <span class="hljs-attr">nofile:</span><br>    <span class="hljs-attr">soft:</span> <span class="hljs-number">20000</span><br>    <span class="hljs-attr">hard:</span> <span class="hljs-number">40000</span><br></code></pre></div></td></tr></table></figure><h2 id="4-compose常用指令"><a href="#4-compose常用指令" class="headerlink" title="4.compose常用指令"></a>4.compose常用指令</h2><p><code>docker-compose [-f=&lt;agr&gt;] [option] [COMMAND] [ARGS...]</code></p><p><code>-f</code>：指定compose模板文件，默认是当前目录的的docker-compose.yml</p><p><code>-p</code>：指定项目名称，默认使用当前目录的名称作为项目名</p><p><code>--verbose</code>：输出更多调试信息</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p>自动完成包括构建镜像，创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>大部分时候都可以直接通过该命令来启动一个项目</p><p><code>-d</code>：后台运行</p><p><code>service</code>：某个服务，默认启动所有服务</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shel">docker-compose up [options] [service...]<br></code></pre></div></td></tr></table></figure><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p>关闭所有的docker-compose服务，并移除网桥</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose down<br></code></pre></div></td></tr></table></figure><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>关闭所有的docker-compose服务，不会移除网桥</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose stop<br></code></pre></div></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除（停止状态的）服务容器</p><p><code>-f</code>：强制删除，包括正在运行的</p><p><code>-v</code>：删除容器所挂载的数据卷</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose rm [option] [service...]<br></code></pre></div></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>和<code>docker exec</code>一样，进入容器，但是使用的是服务名，也不需要使用<code>-it</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose exec 服务名 bash<br></code></pre></div></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>列出<strong>该项目</strong>中所有容器，与<code>docker ps</code>不同</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs she">docker-compose ps<br></code></pre></div></td></tr></table></figure><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查看服务容器内运行的进程</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose top <br></code></pre></div></td></tr></table></figure><h3 id="start、restart"><a href="#start、restart" class="headerlink" title="start、restart"></a>start、restart</h3><p>启动、重启项目中的服务</p><p><code>-t</code>：指定重启前停止容器的超时（默认10秒）</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker-compose restart [option] [service...]<br></code></pre></div></td></tr></table></figure><p>练习 部署mysql和后台应用</p><p>mysql采用dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> mysql:<span class="hljs-number">5.7</span><br><span class="hljs-comment"># 设置工作目录、数据库密码</span><br><span class="hljs-keyword">ENV</span> WORK_DIR=/usr/local/mysql<br><span class="hljs-keyword">ENV</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">1351740185</span><br><span class="hljs-comment">#定义会被容器自动执行的目录</span><br><span class="hljs-keyword">ENV</span> AUTO_RUN_DIR /docker-<span class="hljs-keyword">entrypoint</span><span class="bash">-initdb.d</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$WORK_DIR</span></span><br><span class="hljs-comment">#将sql脚本放在自动执行的目录</span><br><span class="hljs-keyword">COPY</span><span class="bash"> dian-jz.sql <span class="hljs-variable">$AUTO_RUN_DIR</span></span><br><span class="hljs-comment">#增加权限</span><br><span class="hljs-keyword">RUN</span><span class="bash"> chmod a+x <span class="hljs-variable">$AUTO_RUN_DIR</span>/dian-jz.sql</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3306</span><br></code></pre></div></td></tr></table></figure><p>后台：连接数据采用的是数据库服务名:3306</p><p>docker-compose.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">jz01:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;java:8&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-comment">#jar包和logs</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/data/niujiaming/jz/java/jz-0.0.1-SNAPSHOT.jar:/jz.jar</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/data/niujiaming/jz/java/logs:/logs</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9555:8002&quot;</span><br>    <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">jznet</span><br>    <span class="hljs-attr">depends_on:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">jzmysql</span><br>    <span class="hljs-comment">#运行命令</span><br>    <span class="hljs-attr">entrypoint:</span> <span class="hljs-string">java</span> <span class="hljs-string">-jar</span> <span class="hljs-string">jz.jar</span><br>  <span class="hljs-attr">jzmysql:</span><br>    <span class="hljs-attr">build:</span> <br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./mysql</span><br>    <span class="hljs-attr">volumes:</span> <br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/data/niujiaming/jz/mysql/data:/var/lib/mysql</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">/data/niujiaming/jz/mysql/logs:/var/log/mysql</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3307:3306&quot;</span><br>    <span class="hljs-attr">networks:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">jznet</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">jznet:</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习</title>
    <link href="/2021/11/15/Nginx%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/11/15/Nginx%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Nginx简介"><a href="#一、Nginx简介" class="headerlink" title="一、Nginx简介"></a>一、Nginx简介</h1><p>Nginx学习起来并不困难，重点是要多运用才行，不能死记硬背</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Nginx同Apache一样都是一种WEB服务器，作为一台服务器，其根本目的就是要运行我们写的代码。而Nginx专门为性能优化而开发，所以它的功能有限流、负载均衡、反向代理。性能是其最重要的考量</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/070a90dae22c4693858f367bc60934b2~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件.png"></p><h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h2><p>正向代理：安装在客户端的代理(VPN)</p><p>反向代理：安装在服务器端的代理</p><h2 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h2><p>服务器有多台，每台的性能都不一样，由Nginx觉得将请求发送给哪台服务器</p><p>Nginx的请求策略有两种</p><ol><li>内置策略<ul><li>轮询：依次将请求发送给各个服务器，第一个请求第一台服务器，第二个第二台………</li><li>加权轮询：服务器性能越高权重越高，优先将请求发送给权重高的服务器</li><li>Ip hash：对请求的ip进行hash操作，使同一个客户端的多个请求分发给同一台服务器处理，因为各个服务器之间的session是不共享的</li></ul></li><li>扩展策略</li></ol><h2 id="4-动静分离"><a href="#4-动静分离" class="headerlink" title="4.动静分离"></a>4.动静分离</h2><p>动指动态文件，静指静态文件 </p><p>像html、css、jpg这些都是静态文件，不需要经过后台处理，将这些静态文件与动态文件分开部署，以提高资源的相应速度</p><p>但是在目前前后端分离的项目中，个人觉得动静分离的作用不大</p><h1 id="二、部署Nginx"><a href="#二、部署Nginx" class="headerlink" title="二、部署Nginx"></a>二、部署Nginx</h1><blockquote><p> 操作系统为Ubuntu</p></blockquote><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a><strong>1.安装</strong></h2><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">apt-get install nginx</span><br></code></pre></div></td></tr></table></figure><p><strong>查看是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#nginx -v</span><br>nginx version: nginx/1.10.3 (Ubuntu)<br></code></pre></div></td></tr></table></figure><h2 id="2-启动nginx"><a href="#2-启动nginx" class="headerlink" title="2.启动nginx"></a><strong>2.启动nginx</strong></h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#service nginx start</span><br></code></pre></div></td></tr></table></figure><p>提示Job for nginx.service failed because the control process exited with error code. See “systemctl status nginx.service” and “journalctl -xe” for details.</p><p>输入命令<code>systemctl status nginx.service</code>,发现是因为80端口被占用了</p><p>我们查看一下nginx的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#cat /etc/nginx/nginx.conf</span><br></code></pre></div></td></tr></table></figure><p>在/etc/nginx/nginx.conf中并没有看到80端口，但是可以看到它包含了sites-enabled下的文件，再去查看这个，发现这个文件又指向了 site-available/default</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111121038294.png" alt="image-20211112103848264"></p><p>打开default ，可以看到它监听的端口是80，改为81端口，root配置网站根目录，而/var/www/html/就是apache的欢迎页</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111121046989.png" alt="image-20211112104611014"></p><p>访问81端口后会指向/var/www/html/</p><h1 id="三、Nginx常用命令"><a href="#三、Nginx常用命令" class="headerlink" title="三、Nginx常用命令"></a>三、Nginx常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">nginx            <span class="hljs-comment">#启动</span><br>nginx -s reload  <span class="hljs-comment"># 重新加载配置文件，热重启，这个经常使用 </span><br>nginx -s reopen <span class="hljs-comment"># 重启Nginx </span><br>nginx -s stop    <span class="hljs-comment"># 关闭Nginx</span><br>nginx -s quit    <span class="hljs-comment"># 安全退出。等待工作进程处理完成后关闭 </span><br>nginx -T         <span class="hljs-comment"># 查看当前Nginx最终的配置 </span><br>nginx -t         <span class="hljs-comment"># 检查配置是否有问题</span><br></code></pre></div></td></tr></table></figure><h1 id="四、Nginx配置文件"><a href="#四、Nginx配置文件" class="headerlink" title="四、Nginx配置文件"></a>四、Nginx配置文件</h1><p>使用命令 </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#cat /etc/nginx/nginx.conf</span><br></code></pre></div></td></tr></table></figure><p><code>main</code>：在<code>events</code>上面的都是全局配置</p><p><code>events</code>：配置影响 Nginx 服务器与用户的网络连接</p><p><code>http</code> ：配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111121559373.png" alt="第一个配置文件"></p><p><code>http</code>中包含了两个配置文件，该配置文件有对虚拟主机的<code>server</code>配置</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111121609408.png" alt="image-20211112160904519"></p><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#cat /etc/nginx/sites-available/default</span><br></code></pre></div></td></tr></table></figure><p><code>server</code> ：配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块</p><p><code>location</code> ：用于配置匹配的 <code>uri</code> </p><p><code>upstream</code> ：配置后端服务器具体地址，负载均衡配置不可或缺的部分；</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202111121605680.png" alt="第二个配置文件"></p><p>整个的配置文件结构：</p><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//main有关的全局配置</span><br><br>events&#123;<br>worker_connections 768;<br>&#125;<br>http&#123;<br><span class="hljs-comment">//http有关的配置</span><br>    <br>    upstraem dian&#123;<br>       server 8.8.8.1:8081 weight=1;<br>       server 8.8.8.1:8082 weight=1;<br>    &#125;<br>    server&#123;<br>        listen 81;<br>        server_name www.123.com;<br>     <span class="hljs-comment">//对 / 的请求做负载均衡和反向代理</span><br>        location / &#123;<br>        root html;<br>        proxy_pass http://dian;<br>    &#125;<br><span class="hljs-comment">//因为image是静态资源，我们可以不把它放在Tomcat上，也就不用请求server</span><br><span class="hljs-comment">//当访问www.123.com:81/images/XXX时,实际请求路径为/opt/nginx/static/XXX</span><br>        location /image &#123;<br>        root /opt/nginx/static;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>重点是server</p><ul><li><p>upstraem：配置负载均衡，指定服务器的相关信息，这里指定两台后台项目的地址和端口，并在location中配置代理proxy_pass，当访问81端口的/目录时就会将请求发送给 8.8.8.1:8081</p><blockquote><p>注意区分server和server_name，server_name指访问的地址，server指后台服务的地址</p><p>访问：server_name:listen/  代理到：proxy_pass</p><p>访问：<a href="http://www.123.com/">www.123.com:80/</a>  会代理到 <a href="http://8.8.8.1:8081/">http://8.8.8.1:8081/</a></p><p>Q：为什么要配置server_name？我们完全可以通过服务器IP:端口进行访问</p><p>A：server_name是起的一个标记名称。服务器IP只有一个，可能会出现一台服务器对应多个项目的情况，这样就可以使用server_name实现同一ip不同域名的需求。<br>当我们通过hosts文件指定IP与域名的对应关系（186.11.124.120(服务器公网IP)   <a href="http://www.123.com)之后,对域名的访问会映射成对应的ip,然后server/">www.123.com）之后，对域名的访问会映射成对应的IP，然后server</a> name为虚拟服务器的识别路径。因此不同的域名会转发到对应的应用服务器中去。<br>类似于git的origin，origin是一个别名，指向一个远程仓库，我们可以在同一个本地仓库中origin1指向github地址，定义origin2指向gitee地址，通过oring1、2向不同的远程仓库进行提交</p></blockquote></li><li><p>listen：监听的端口</p></li><li><p>server_name 指定虚拟主机域名，例如：server_name <a href="http://www.123.com/">www.123.com</a></p></li><li><p>root 指定静态资源目录位置，可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 配置中</p></li><li><p>location：配置路径</p><p>匹配规则    匹配优先级： <code>=</code> &gt; <code>^~</code> &gt;  <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符</p><ul><li><code>=</code> 精确匹配</li><li><code>~</code> 正则匹配，区分大小写</li><li><code>~*</code> 正则匹配，不区分大小写</li><li><code>^~</code> 匹配到即停止搜索</li></ul><p>例： location = /image/       location = /image</p><p>是否有反斜杠：<code>Nginx</code> 先找是否有 <code>images</code> 目录，如果有则找 <code>images</code> 目录下的 <code>index.html</code> </p><p>​        没有的话：不带反斜杠<strong>会</strong>去找是否有<code>image</code>文件；</p><p>​                           带反斜杠<strong>不会</strong>去找是否存在 <code>image</code>文件</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习</title>
    <link href="/2021/08/20/Vue%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/20/Vue%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>Vue官方文档：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a><br>Vue 是一个采用 MVVM 架构, 通过数据驱动视图的形式来构建用户界面的渐进式框架<br>“渐进式” 的意思就是从少到多, 从弱到强，需要什么用什么</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM最早由微软提出来，它借鉴了MVC思想，在前端页面中，把Model(数据)用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离，把Model和View关联起来的就是ViewModel。<br>ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理<br>我们并不关心DOM的结构，而是关心数据如何存储。最简单的数据存储方式是使用js对象：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Bart&#x27;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-8b7eb02a65d3604aa02c0e495a7b2fc6_720w.jpg" alt="img"><br>MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而不需要操作繁琐的DOM</p><h2 id="虚拟化DOM"><a href="#虚拟化DOM" class="headerlink" title="虚拟化DOM"></a>虚拟化DOM</h2><p>在对数据进行操作后并不会将现数据完全覆盖掉原数据，而是放在虚拟DOM中，通过Diff算法与原数据进行比较，得出应施加到真实 DOM 上的改动</p><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><p>Vue-router 是 Vue.js 官方的路由插件，与 Vue.js 深度集成，用于构建单页面应用。Vue 单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来，传统的页面是通过超链接实现页面的切换和跳转的。Vue是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和dom</p><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>前端的业务逻辑也变的非常复杂，再不是传统意义上的一个文件夹放 html、一个文件夹放js、一个文件夹放css就能搞定的。所以我们要分模块。<br>一个页面可能会有很多模块需要编写，比如导航栏、侧边栏、底部栏，vue将一个网页拆分成单个组件，每个组件都包含属于自己的html、css和js，哪个页面需要就去调用对应的组件</p><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>vue数据代理: <strong>data</strong>对象的所有属性的操作(读/写)由vm对象来代理操作</p><p>原理：</p><ol><li>通过<strong>Object.defineProperty</strong>(vm, key, {})给vm添加与data对象的属性对应的属性</li><li>所有添加的属性都包含get/set方法</li><li>在get/set方法中去操作data中对应的属性</li></ol><p>获得data中的对象其实是调用了get方法</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p><p>beforeCreate()    实例将要创建</p><p><strong>created()</strong>    实例创建完成之后</p><p>beforeMount()    实例将要挂载</p><p><strong>mounted()</strong>    实例被挂载后调用。Vue完成模板的解析并把真实的DOM元素放入页面后调用mounted</p><p>beforeUpdate 将要更新</p><p>updated() 更新完成</p><p><strong>beforeDestroy()</strong> 将要销毁</p><p>destroyed()    销毁完成</p><h1 id="二、指令"><a href="#二、指令" class="headerlink" title="二、指令"></a>二、指令</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a>v-bind:</h2><p>单向绑定，可以用于响应式地更新 HTML attribute。能够接收一个“参数”，在指令名称之后以<strong>冒号</strong>表示。</p><p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。<br>也可以使用其他的参数名</p><blockquote><p><strong>插值语法</strong>用于标签体中的内容，<strong>指令语法</strong>(以v-开头)管理标签(标签属性、标签体内容、绑定事件) 比如 href=”xxx”</p></blockquote><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello,&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> <br>      <span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>点击进入我的gitee<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 缩写  --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>点击进入我的gitee<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">       <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">           el:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br>           data:&#123;<br><span class="javascript">               name:<span class="hljs-string">&#x27;点&#x27;</span>,</span><br><span class="javascript">               url:<span class="hljs-string">&#x27;https://gitee.com/lingdiand&#x27;</span></span><br>           &#125;&#125;)<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>双向绑定，该指令只能用于<strong>表单类元素</strong>中</p><blockquote><p> v-model:value=”name” 可简写为 v-model=”name”，因为v-model默认收集的就是value值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 缩写  --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">const</span> x=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="javascript">            data:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;点&#x27;</span>&#125;&#125;)</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>v-on绑定事件监听，可简写为@</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 如果传递参数需加小括号--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 缩写 (常用缩写)--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>条件渲染</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">       <span class="hljs-keyword">const</span> x=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">           el:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br>           data:&#123;<br><span class="javascript">              <span class="hljs-string">&quot;ok&quot;</span>:<span class="hljs-literal">true</span></span><br>           &#125;<br>       &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>当值为false时<strong>v-if</strong>会移除该元素，而<strong>v-show</strong>会显示该元素，但是使用 display:none隐藏</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!--show为数据--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210716181517.png" alt="image-20210716181508191"></p><p>比如我们有一个编辑员工信息的框，如果员工离职，则需要输入离职日期，在职则不需要输入离职日期(隐藏离职日期框)，这时候就要使用v-if，因为v-show仅仅使日期框隐藏，但日期框还是会被渲染，其规则还是存在</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>用于展示列表数据</p><p>v-for=”(i,index) in list” :key=”i.id”     key唯一标识</p><p>可循环数组、对象、字符串、指定次数</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i.id&quot;</span>&gt;</span>&#123;&#123;i.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><h1 id="三、组件介绍"><a href="#三、组件介绍" class="headerlink" title="三、组件介绍"></a>三、组件介绍</h1><p>vue.js和vue框架<br>vue.js只是vue框架里面的其中一个文件，如果只是在单个页面中使用vue，可以看成和JQ一样，简化dom操作<br>以前的项目是jsp+java，jsp嵌入后端项目中。而现在是前后端分离，页面脱离jsp变为html，但随着前端开发越来越复制，因此就有了遵循模块化的设计。前端项目的代码结构和分层的与后端的框架差不多，再也不是以前那种直接在一个 js 文件里从上到下一顺儿写下来的样子<br><strong>vue-cli</strong>：Vue的脚手架工具，通过它来创建大的项目环境，可以选择需要使用的工具。用于自动生成Vue项目的目录及文件<br><strong>vue-router</strong>： Vue提供的前端路由工具，利用其我们实现页面的路由控制，局部刷新及按需加载，构建单页应用，实现前后端分离。<br><strong>vuex</strong>：Vue提供的状态管理工具，用于统一管理我们项目中各种数据的交互和重用，存储我们需要用到数据对象。<br><strong>npm</strong>：node.js的包管理工具，用于同一管理我们前端项目中需要用到的包、插件、工具、命令等，便于开发和维护，配置文件是package.json。<br><strong>webpack</strong>：一款强大的文件打包工具，可以将我们的前端项目文件同一打包压缩至js中，并且可以通过vue-loader等加载器实现语法转化与加载。</p><h1 id="四、npm命令解释"><a href="#四、npm命令解释" class="headerlink" title="四、npm命令解释"></a>四、npm命令解释</h1><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h2><ul><li><code>i</code> 是 <code>install</code> 的简写</li><li><code>-g</code> 是全局安装，不带 <code>-g</code> 会安装在项目目录，但不会写入package.json，带<code>-g</code>安装在磁盘下</li><li><code>-S</code> 与 <code>--save</code> 的简写，安装包信息会写入 <code>dependencies</code> 中。<strong>常用这个</strong><br>下载第三方插件的时候使用–save，会在package.json配置依赖，方便他人使用我们项目时下载所需依赖</li><li><code>-D</code> 与 <code>--save-dev</code> 的简写，安装包写入 <code> devDependencies</code> 中</li></ul><h2 id="2-dependencies-与-devDependencies"><a href="#2-dependencies-与-devDependencies" class="headerlink" title="2.dependencies 与 devDependencies"></a>2.dependencies 与 devDependencies</h2><ul><li><strong>dependencies</strong> 生产阶段的依赖,也就是项目部署服务器运行时的依赖</li><li><strong>devDependencies</strong> (develop)开发阶段的依赖，就是我们在开发过程中需要的依赖，只在开发阶段起作用的</li></ul><p>例：开发阶段中编写代码使用的eslint检查代码规范，但在项目上线后，就不需要了，这样就属于<strong>devDependencies</strong></p><p>如果使用 Element-UI，由于发布到生产后还是依赖 Element-UI，这就可以安装到 <strong>dependencies</strong> </p><h2 id="3-cnpm"><a href="#3-cnpm" class="headerlink" title="3.cnpm"></a>3.cnpm</h2><p>npm默认去外网中找依赖，速度很慢，所以需要镜像</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org<br>cnpm install<br></code></pre></div></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>npm下载的依赖即可在<strong>磁盘</strong>也可在<strong>项目目录</strong>，像vue-cli、hexo、cnpm这些<strong>构造项目前</strong>使用的工具使用**-g<strong>，vue、router、vuex</strong>项目中<strong>使用的模块使用</strong>–save**</p><p>使用原则:运行时需要用到的模块使用–save，否则使用–save-dev。</p><p><strong>devDependencies</strong> 属性下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。</p><p>使用**–save、–save-dev**会在package.json将模块依赖写入，运行 npm install 初始化项目时，会将模块下载到项目目录下。</p><h1 id="五、vue-cli安装"><a href="#五、vue-cli安装" class="headerlink" title="五、vue-cli安装"></a>五、vue-cli安装</h1><p>创建Vue项目前需要已经安装了node.js</p><h2 id="1-安装vue-cli、-vue-cli"><a href="#1-安装vue-cli、-vue-cli" class="headerlink" title="1.安装vue-cli、 @vue/cli"></a>1.安装vue-cli、 @vue/cli</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g vue-cli<span class="hljs-comment">#安装vue-cli，这一步安装的是2.9版本</span><br>npm install -g @vue/cli <span class="hljs-comment">#安装vue-cli，这一步安装的是3.0版本 版本不同有些命令也不同，建议安装3.0</span><br>npm install -g @vue/cli-service-global <span class="hljs-comment">#CLI服务(@vue/cli-service) 是一个开发环境依赖。它是一个 npm包，局部安装在每个@vue/cli创建的项目中。</span><br></code></pre></div></td></tr></table></figure><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><p>注意选择一个工作目录</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vue create hello-world<br></code></pre></div></td></tr></table></figure><p>提示</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vue create is a Vue CLI 3 only <span class="hljs-built_in">command</span> and you are using Vue CLI 2.9.6.<br>  You may want to run the following to upgrade to Vue CLI 3:<br></code></pre></div></td></tr></table></figure><p>因为我们安装的脚手架是2.9.6版本。2.9.6 创建项目是用 vue init webpack my-project </p><p>3.0以上 初始化项目是用 vue create my-project解决方法：</p><p>1.使用2.9.6版本的命令vue init webpack my-project<br>2.卸载2.9.6版本，安装3.0版本</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm uninstall -g vue-cli<br>npm install -g @vue/cli<br></code></pre></div></td></tr></table></figure><h2 id="3-选择preset"><a href="#3-选择preset" class="headerlink" title="3.选择preset"></a>3.选择preset</h2><p>继续创建项目，会被提示选取一个 preset(可以理解是一个安装模板)，默认选择Vue2版本，<strong>这里是Vue的版本，和vue-cli插件的版本不是同一个</strong>，脚手架只是一个工具，版本的不同只是带来命令格式的不同，而vue版本的不同会导致不同项目的兼容，比如有些第三方插件基于vue2创建，如果使用的是vue3就不能够使用<br><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717104406.png" alt="image-20210717104357687"><br>我们选择第三个 自定义，看一下都会安装哪些东西<br>光标移动，空格选中<br><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717105246.png" alt="img"><br>这就是脚手架的好处，它把搭建项目所需的东西都集成了，我们可以选择需要的<br><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717110003.png" alt="image-20210717110002197"><br>choose vue version：选择vue版本<br>Babel ：将高级版本ES转换为浏览器识别的JS语法，ES6-&gt;ES5<br>TypeScript： JS的超集，提供了JS面向对象支持<br>Progressive Web App (PWA) Support PWA Support:使应用向原生APP<br>Router :路由、请求所对应的地址<br>Vuex: 数据状态管理器、用于多页面传参<br>CSS Pre-processors: CSS预处理，将高级CSS语法转换为浏览器识别CSS语法<br>Linter / Formatter :代码检查工具,语法检测，严格，项目开发推荐<br>Unit Testing :单元测试<br>E2E Testing :端端测试</p><h2 id="4-一些配置"><a href="#4-一些配置" class="headerlink" title="4.一些配置"></a>4.一些配置</h2><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717112738.png" alt="image-20210717112737018"></p><h2 id="5-创建完成"><a href="#5-创建完成" class="headerlink" title="5.创建完成"></a>5.创建完成</h2><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717114123.png" alt="image-20210717114122474"></p><h1 id="六、vue-cli使用"><a href="#六、vue-cli使用" class="headerlink" title="六、vue-cli使用"></a>六、vue-cli使用</h1><h2 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="1.结构分析"></a>1.结构分析</h2><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210717114203.png" alt="image-20210717114201105"></p><ol><li><p>node_modules：安装的所有工具</p></li><li><p><strong>package.json</strong>：node环境下都有这个文件，用于包管理。<strong>我们之前安装的第三方依赖的名字和版本号都在这里面显示，如果项目是别人的，要先进行<code>npm install    </code> 安装依赖</strong></p><ul><li>name - 包名</li><li>version - 包的版本号</li><li>description - 包的描述</li><li>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下</li><li>repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上</li></ul></li><li><p>public：indexl.html文件 ，文件入口</p></li><li><p><strong>src</strong>：放置组件和入口文件</p><ul><li>assets：静态资源</li><li>components：可复用的组件，单个模块级别的组件，比如导航栏</li><li><strong>router</strong>：路由，用于页面跳转，把准备好路由组件注册到路由里</li><li><strong>views</strong>：存放编写的页面，单个页面级别的组件</li><li>store：存放公共变量</li><li><strong>main.js</strong>：项目的入口，项目中的所有页面都会加载main.js，是初始化vue实例并使用需要的插件</li><li><strong>App.vue</strong>：是我们的主组件，页面入口文件，所有页面都是在App.vue下进行切换的。也是整个项目的关键，App.vue负责构建定义及页面组件归集。</li></ul></li><li><p>vue.config.js：vue-cli3 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，需要手动创建。</p></li></ol><p>项目运行后会加载public/index.html，因为脚手架配置了main.js，所以main.js实例化App.vue，App.vue中有两个路由链接。进入route/index.js可以看到两个路由链接的源来自view/Home.vue和About.vue，Home.vue使用了组件components/HelloWorld.vue</p><h2 id="2-main-js"><a href="#2-main-js" class="headerlink" title="2.main.js"></a>2.main.js</h2><p><strong>main.js编写脚本，App.vue编写页面</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//  引入Vue，这是ES6的引入语法</span><br><span class="hljs-comment">//  之前需要通过script标签引入</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 引入APP组件，它是所有组件的父组件</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-comment">//  关闭Vue的生产提示</span><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br><span class="hljs-comment">//  创建Vue的实例对象</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  store,<br>  <span class="hljs-comment">//  将App组件放入容器中</span><br>  <span class="hljs-comment">//  render:createElement=&gt;createElement(App)</span><br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h2 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h2><p>在README.md文件中有运行项目所需的常用命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install<span class="hljs-comment">#安装依赖</span><br>npm run serve <span class="hljs-comment">#在本地运行项目</span><br>npm run build <span class="hljs-comment">#打包项目，用于项目完成后进行打包部署</span><br></code></pre></div></td></tr></table></figure><p>npm run dev和npm run serve的不同<br>打开package.json，在scripts中可以看到key：value<br>当我们运行npm run serve时其实运行的命令是vue-cli-service serve，如果要使用dev，将serve改为dev即可<br>npm run dev 是 vue-cli2    npm run serve 是 vue-cli3</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;vue-cli-service serve&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;vue-cli-service build&quot;</span>,<br>  <span class="hljs-string">&quot;test:unit&quot;</span>: <span class="hljs-string">&quot;vue-cli-service test:unit&quot;</span>,<br>  <span class="hljs-string">&quot;lint&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint&quot;</span><br>&#125;,<br></code></pre></div></td></tr></table></figure><h1 id="七、ESLint"><a href="#七、ESLint" class="headerlink" title="七、ESLint"></a>七、ESLint</h1><p>如果我们在创建项目时使用了ESLint，当运行时代码不符合ESLint规范时就会报错，但是并不会提示具体报错的位置和信息</p><p>VsCode插件中安装ESLint，就可以自动检测不符合规范的代码。但是这样需要我们手动一个一个修复，网上有很多教程但是太复杂了。而我们的需求是：当我们进行<strong>格式化文档</strong>(shift+alt+F)的时候可以自动帮我们修复格式不正确的代码</p><p>打开设置，搜索ESLint，勾选  启用ESLint作为格式化程序 </p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202108151312973.png" alt="image-20210815131220810"></p><p>这样当我们进行格式化时会出现选项，选择ESLint即可</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202108151315936.png" alt="image-20210815131548689"></p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/202108151316862.png" alt="image-20210815131611782"></p><h1 id="八、axios"><a href="#八、axios" class="headerlink" title="八、axios"></a>八、axios</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install axios --save<br></code></pre></div></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h2><p>在main.js文件中引入<br>如果要全局使用axios就需要在main.js中设置成全局的，然后再组件中通过this调用</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为axios不是vue的插件，所以不能直接用use方法，需要将其加载到原型上。</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-comment">// axios需要使用prototype将axios挂载到原型上 ，即自己手动增加了一个Vue的属性。$后面是自己另起的名称，以后就可以使用该名称</span><br>Vue.prototype.$axios=axios;<br></code></pre></div></td></tr></table></figure><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p>第一种</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$axios.get(<span class="hljs-string">&quot;127.0.0.1:8000&quot;</span>).then(<br>  (response) =&gt; &#123;<span class="hljs-comment">//如果成功的话返回</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;请求成功&quot;</span>, response.data);<br>  &#125;,<br>  (error) =&gt; &#123;        <span class="hljs-comment">//如果失败的话返回</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;请求失败&quot;</span>, error.message);<br>  &#125;<br>);<br></code></pre></div></td></tr></table></figure><p>第二种</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$axios(&#123;<br>        method: <span class="hljs-string">&#x27;post&#x27;</span>, <span class="hljs-comment">// 指定请求方式</span><br>        url: <span class="hljs-string">&#x27;/user/getById&#x27;</span>, <span class="hljs-comment">// 请求接口</span><br>        data: &#123; <span class="hljs-comment">// 发送的数据</span><br>          id: <span class="hljs-number">1</span><br>        &#125;<br>      &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 接口成功返回结果执行</span><br>      &#125;).catch(<span class="hljs-function">(<span class="hljs-params">erro</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 接口失败返回结果执行</span><br>      &#125;)<br></code></pre></div></td></tr></table></figure><h1 id="九、vue-router"><a href="#九、vue-router" class="headerlink" title="九、vue-router"></a>九、vue-router</h1><h2 id="1-基本路由"><a href="#1-基本路由" class="headerlink" title="1.基本路由"></a>1.基本路由</h2><ol><li><p>创建路由配置项</p><blockquote><p> 如果没有加路由的组件，第一步应该是创建组件</p></blockquote><p>在router/index.js</p></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.引入vue-router</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 2.创建路由配置，是一个数组对象</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-comment">// 浏览器url显示的内容</span><br>    name: <span class="hljs-string">&#x27;Home&#x27;</span>,<br> <span class="hljs-comment">//加载的组件名，即其他页面中定义的</span><br> <span class="hljs-comment">/* export default &#123;</span><br><span class="hljs-comment">  name: &#x27;Home&#x27;&#125; */</span><br>    component: Home<br>  &#125;,<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    component: About<br>  &#125;<br>]<br><span class="hljs-comment">// 3.创建路由器，并把上一步的路由配置加入，因为key和value的名称都为router，可以省略</span><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    <span class="hljs-comment">//routes: routes</span><br>routes<br>&#125;)<br><span class="hljs-comment">// 4.暴露router</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>引入</p><p>在main.js</p><p>第一步引入的是路由插件，这一步加入我们暴露的router</p></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-comment">//在nue Vue中加入router</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router,<br>  store,<br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></div></td></tr></table></figure><ol start="3"><li><p>router-link标签</p><p><strong>创建</strong>：第一步配置了路由，路径和组件之间的映射；</p><p><strong>注册</strong>：第二步在App中加入了路由，即vue知道了我们的路由配置；</p><p><strong>使用</strong>：第三步可以使用我们的路由配置了，配置路由链接(相当于a链接)和需要展示组件的区域</p><p>在导航栏中(App.vue)</p></li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">//实现切换 to表示路径，指第一步配置的组件路径需要加/，<br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>//展示组件位置 <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-嵌套-多级-路由"><a href="#2-嵌套-多级-路由" class="headerlink" title="2.嵌套(多级)路由"></a>2.嵌套(多级)路由</h2><p>Home组件原本只有文本内容，显示需要显示两个导航链接news、message</p><ol><li><p>新建两个组件news和message并配置好暴露的名称</p></li><li><p>编写路由规则children属性</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;<br>    path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    component: Home,<br>    children: [<br>      &#123;<br>        <span class="hljs-comment">// 一级路由需要加/，其他不需要,会自动加上</span><br>        path: <span class="hljs-string">&#x27;news&#x27;</span>,<br>        component: News<br>      &#125;, &#123;<br>        path: <span class="hljs-string">&#x27;message&#x27;</span>,<br>        component: Message<br>      &#125;]&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在父组件Home中使用   <strong>二级路由使用：父路径+子路径</strong></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/news&quot;</span>&gt;</span>News<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/message&quot;</span>&gt;</span>Message<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ol><h1 id="十、vue-element-admin框架"><a href="#十、vue-element-admin框架" class="headerlink" title="十、vue-element-admin框架"></a>十、vue-element-admin框架</h1><h2 id="1-登录接口请求详解"><a href="#1-登录接口请求详解" class="headerlink" title="1.登录接口请求详解"></a>1.登录接口请求详解</h2><ul><li><p>页面：用户单击登录，通过store转发到user的login方法</p></li><li><p>store/user：共享数据。login方法调用api/user下的login方法</p></li><li><p>api/user：请求处理。login方法下的url为/uesr/login，mock进行拦截</p></li><li><p>mock：模拟数据。mock中有/user/login，匹配到api的/user/login，创建token名为XXX-token和code并返回。code值可以在request.js中查看</p></li><li><p>store中返回token，因为request封装了axios，会根据返回的code判断是否成功，成功调用utils/auth将token存储cookie中，失败则给出错误提示</p><p>我们通过用户名获得对应的token，该token是唯一标示用户身份的一个key，再通过token获得对应的用户信息，其中只有token存储在本地</p><p>permission会先从 cookie 中查看是否存有 token，没有就执行登录流程，如果有token,就会把这个 token 返给后端user/info接口去拉取user_info。 </p></li></ul><p>login返回数据格式</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">20000</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;token&quot;</span>: <span class="hljs-string">&quot;admin-token&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> info返回数据格式</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>:<span class="hljs-number">20000</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;roles&quot;</span>:[<span class="hljs-string">&quot;admin&quot;</span>],<br>        <span class="hljs-attr">&quot;introduction&quot;</span>:<span class="hljs-string">&quot;I am a super administrator&quot;</span>,<br>        <span class="hljs-attr">&quot;avatar&quot;</span>:<span class="hljs-string">&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;Super Admin&quot;</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p> logout返回数据格式</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>:<span class="hljs-number">20000</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>:<span class="hljs-string">&quot;success&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2-更改为自己后台接口"><a href="#2-更改为自己后台接口" class="headerlink" title="2.更改为自己后台接口"></a>2.更改为自己后台接口</h2><p>更改前端接口</p><ul><li>.env.development：VUE_APP_BASE_AP更改为自己后台的接口</li><li>vue.config.js：注释掉before: require(‘./mock/mock-server.js’)，before属性是引入mock.js用前端产生假数据来进行前后交互</li><li>@api中url更改为后台提供的api</li></ul><p>后台提供api并返回相应的格式</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br>    <span class="hljs-meta">@PostMapping</span> (value = <span class="hljs-string">&quot;login&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>        HashMap&lt;String, Object&gt; response = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        HashMap&lt;String, Object&gt; responseData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        responseData.put(<span class="hljs-string">&quot;token&quot;</span>,<span class="hljs-number">1</span>);<br>        response.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">20000</span>);<br>        response.put(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;登录成功&quot;</span>);<br>        response.put(<span class="hljs-string">&quot;data&quot;</span>,responseData);<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping(value = &quot;info&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;String, Object&gt; responseInfo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        HashMap&lt;String, Object&gt; responseData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        responseData.put(<span class="hljs-string">&quot;roles&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>        responseData.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Super admin123456&quot;</span>);<br>        responseData.put(<span class="hljs-string">&quot;avatar&quot;</span>,<span class="hljs-string">&quot;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&quot;</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">20000</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;登录成功&quot;</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;data&quot;</span>,responseData);<br>        <span class="hljs-keyword">return</span> responseInfo;<br>    &#125;<br>&#125;<br>    <span class="hljs-meta">@PostMapping(value = &quot;logout&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">logout</span><span class="hljs-params">()</span> </span>&#123;<br>        HashMap&lt;String, Object&gt; responseData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        responseData.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">20000</span>);<br>        responseData.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;退出成功&quot;</span>);<br>        responseData.put(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>        <span class="hljs-keyword">return</span> responseData;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>这个是假登录，不会判断输入信息的正确性，如果需要自定义账户，采用下面这种</p><p>创建一个user.properties，自定义用户信息</p><figure class="highlight properties"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-meta">user.token</span>=<span class="hljs-string">admin-token</span><br><span class="hljs-meta">user.roles[0]</span>=<span class="hljs-string">admin</span><br><span class="hljs-meta">user.introduction</span>=<span class="hljs-string">I am a super administrator</span><br><span class="hljs-meta">user.avatar</span>=<span class="hljs-string">https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif</span><br><span class="hljs-meta">user.username</span>=<span class="hljs-string">admin</span><br><span class="hljs-meta">user.password</span>=<span class="hljs-string">123456</span><br></code></pre></div></td></tr></table></figure><p>创建一个User类，加载指定的配置文件，将用户信息存入其中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:user.properties&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span>  String token;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; roles;<br>    <span class="hljs-keyword">private</span> String introduction;<br>    <span class="hljs-keyword">private</span> String avatar;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br></code></pre></div></td></tr></table></figure><p>登录，将入参用户名和密码与配置文件数据进行对比，成功返回一个token，值为 用户名-token</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>User userInfo;<span class="hljs-comment">//在方法外声明，该对象中保存了配置文件中的数据</span><br><br><span class="hljs-meta">@PostMapping(value = &quot;login&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User loginUser)</span> </span>&#123;<br>    String username = loginUser.getUsername();<br>    String password = loginUser.getPassword();<br>    HashMap&lt;String, Object&gt; response = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    HashMap&lt;String, Object&gt; responseData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//如果用户名和密码正确</span><br>    <span class="hljs-keyword">if</span> (userInfo.getUsername().equals(username) &amp;&amp; userInfo.getPassword().equals(password)) &#123;<br>        <span class="hljs-comment">//根据用户名生成token</span><br>        responseData.put(<span class="hljs-string">&quot;token&quot;</span>, username + <span class="hljs-string">&quot;-token&quot;</span>);<br>        response.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">20000</span>);<br>        response.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>        response.put(<span class="hljs-string">&quot;data&quot;</span>, responseData);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        response.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">60204</span>);<br>        response.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;账号或密码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>获得用户信息，根据入参token判断是否与配置文件数据相同</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;info&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">info</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;token&quot;)</span> String token)</span> </span>&#123;<br>    HashMap&lt;String, Object&gt; responseInfo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//如果token匹配</span><br>    <span class="hljs-keyword">if</span> (userInfo.getToken().equals(token)) &#123;<br>        responseInfo.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">20000</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录成功&quot;</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;data&quot;</span>, userInfo);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        responseInfo.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">50008</span>);<br>        responseInfo.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录失败，不能获得用户信息&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> responseInfo;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-跨域问题"><a href="#3-跨域问题" class="headerlink" title="3.跨域问题"></a>3.跨域问题</h2><p> 产生 跨域的主要问题是 <strong>协议、域名、端口号</strong> 三者有一点不同就会产生跨域问题</p><ul><li>全局配置    </li></ul><p>在后台项目中添加配置文件CORSConfig.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CORSConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)   <span class="hljs-comment">//限定访问路径为</span><br>                .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)            <span class="hljs-comment">//允许来自*跨域访问,还有一种是这样allowedOriginPatterns(&quot;*&quot;)</span><br>                .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;PUT&quot;</span>,<span class="hljs-string">&quot;OPTIONS&quot;</span>,<span class="hljs-string">&quot;DELETE&quot;</span>,<span class="hljs-string">&quot;PATCH&quot;</span>) <span class="hljs-comment">//限定访问方法</span><br>                .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>                .allowCredentials(<span class="hljs-keyword">true</span>)<br>                .maxAge(<span class="hljs-number">3600</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>局部配置</li></ul><p>在需要使用跨域的接口、方法中使用注解@CrossOrigin(origins = “<a href="http://localhost:9000/">http://localhost:</a>9527”)。参数可省</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2021/07/25/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/25/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Git介绍"><a href="#一、Git介绍" class="headerlink" title="一、Git介绍"></a>一、Git介绍</h1><h2 id="1-什么是Git"><a href="#1-什么是Git" class="headerlink" title="1.什么是Git?"></a>1.什么是Git?</h2><p>git为一个分布式的版本控制软件，由林纳斯创作，最初是用于更好地管理Linux内核的开发，因为提交Linux功能的人太多了，最终都需要手动进行合并代码</p><p>分布式在于每个人都可以拷贝完整的项目到本地进行开发</p><p>版本控制：Git会保留每次提交时的commitID，这样可以回滚到之前的版本</p><span id="more"></span><p>使用Git，不但能自动记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要瞄一眼就可以</p><h2 id="2-名词介绍"><a href="#2-名词介绍" class="headerlink" title="2.名词介绍"></a>2.名词介绍</h2><p>工作区：就是工作的区域，写代码的地方，在文件夹中使用git init命令后，该文件夹变为工作区，我们所有的操作都是在该文件夹中进行</p><p>暂存区：使用git add &lt;文件名&gt;可以将文件放到暂存区，是我们把文件进行提交前的一个过渡阶段，临时存储。所有暂存的文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</p><p>本地仓库：使用git commit会将暂存区内容提交到本地仓库中，如果我们在commit后再次修改文件，则需要再次git add</p><p>远程仓库：和本地仓库一样，但是位于远端(服务器)，在团队开发中我们需要一个远程仓库进行提交(push)、下载(pull)我们的项目，用于团队协作开发</p><p>远程仓库副本：可以理解为存在于本地的远程仓库缓存。如需更新，可通过git fetch/pull命令获取远程仓库内容。使用fech获取时，并未合并到本地仓库，此时可使用git merge实现远程仓库副本与本地仓库的合并</p><p>当我们提交项目时会经过暂存(git add *)-&gt;提交(git commit)-&gt;上传远端(git push)</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210722210005.jpeg"></p><h2 id="3-Git仓库组成"><a href="#3-Git仓库组成" class="headerlink" title="3.Git仓库组成"></a>3.Git仓库组成</h2><p>使用git init命令后生成.git隐藏文件夹，该文件夹中存放的是我们所提交的文档索引内容，Git 可基于文档索引内容对其所管理的文档进行内容追踪，从而实现文档的版本控制。</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210724212912.png"></p><p>config文件：用于配置本地仓库的一些信息，仓库名、当前分支、绑定的远程仓库地址</p><p>Index（索引）：进行过提交的操作后会有该文件。将工作目录下所有文件（包含子目录）生成快照，存放到一个临时的存储区域，Git 称该区域为索引</p><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1.基本命令"></a>1.基本命令</h2><blockquote><p> 命令的操作都是在工作区下进行</p><p> git中可以使用Linux命令</p><p> git中的复制粘贴可以选中要复制的内容，按鼠标中键</p></blockquote><p>设置签名</p><p>配置完成后可以在C:\Users\${用户名}\.gitconfig中看到</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git config --global user.email <span class="hljs-string">&quot;1351740185@qq.com&quot;</span><br>git config --global user.name <span class="hljs-string">&quot;lingdiand&quot;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git init<span class="hljs-comment">#将项目交给git管理，在项目根目录下出现.git文件夹</span><br>git add * <span class="hljs-comment">#将所有未被git管理的文件纳入到git的管理中，可以理解为该文件被git所跟踪</span><br>git status<span class="hljs-comment">#查看当前文件的状态(有哪些文件更改了没有提交)</span><br>git commit -m <span class="hljs-string">&#x27;提交了XXX&#x27;</span>  <span class="hljs-comment">#将代码提交到本地仓库，-m 提交注释,可以说明自己这次提交做了些什么</span><br></code></pre></div></td></tr></table></figure><p>关于远程仓库的解释下面会讲到</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git remote add origin https://gitee.com/group-8-dian/hsp.git <span class="hljs-comment">#将本地仓库与远程仓库绑定</span><br>git remote show origin <span class="hljs-comment">#显示远程库origin里的资源 </span><br>git push origin master  <span class="hljs-comment">#将本地仓库推送到远程仓库</span><br>git pull origin master<span class="hljs-comment">#下载远程仓库的项目(团队开发要先下载再上传)</span><br>git fetch origin master<br></code></pre></div></td></tr></table></figure><blockquote><p>origin为远程仓库名，master为分支名</p><p>pull=fetch+merge    git fetch并没有更改本地仓库的代码，只是拉取了远程仓库的commitID</p></blockquote><h2 id="2-状态查看"><a href="#2-状态查看" class="headerlink" title="2.状态查看"></a>2.状态查看</h2><p>reset一共有三种模式</p><ul><li>–hard：不保留所有变更，所有的一切都会还原到哈希值对应项目的状态</li><li>–soft：保留变更且变更内容处于Staged</li><li>–mixed：保留变更且变更内容处于Modified</li></ul><blockquote><p>log和reflog中显示的哈希值其实是一样的，通过reset可以回退版本</p><p>在 Git 中，用 <strong>HEAD</strong> 表示当前版本，也就是最新的提交 commit id，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 HEAD~100</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><span class="hljs-comment">#查看日志信息</span><br>git reflog<span class="hljs-comment">#查看所有操作记录</span><br>git reset --hard 版本号<span class="hljs-comment">#回滚，版本号为日志中的哈希值</span><br>git reset --hard HEAD^<span class="hljs-comment">#回退上一个版本</span><br></code></pre></div></td></tr></table></figure><p><strong>文件状态：</strong></p><ol><li>没有被add过的文件叫untracked</li><li>add之后文件处于staged状态，等待commit</li><li>commit之后文件处于unmodified，如果是modified是因为文件会跟仓库中的文件对比</li><li>当unmodified的文件被修改则会变为modified状态</li><li>modified之后的文件add之后将继续变为staged状态</li><li>unmodifed的文件还有一种可能是已经不再需要了，那么可以remove它不再追踪变为untracked状态</li></ol><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210724223819.png"></p><h2 id="3-分支命令"><a href="#3-分支命令" class="headerlink" title="3.分支命令"></a>3.分支命令</h2><p>在初始化仓库时默认分支为master(主分支)，前面在切换版本时需要不停的reset，我们可以通过分支来解决频繁的操作，Git 鼓励在工作流程中频繁使用分支与合并</p><p>在开发过程中，一般不对master进行修改，而是不同的部门、功能小组划分不同的分支进行开发，没有问题了合并到 master 分支发布。</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git branch &lt;branchName&gt;   <span class="hljs-comment">#只是新建了一条分支，并未切换</span><br>git checkout -b &lt;branchName&gt;   <span class="hljs-comment">#创建并切换分支</span><br>git branch -d &lt;branchName&gt;   <span class="hljs-comment">#删除分支</span><br>git checkout master<span class="hljs-comment">#切换主分支</span><br>git branch<span class="hljs-comment">#查看所有分支</span><br>git merge &lt;branchName&gt;<span class="hljs-comment">#合并分支</span><br></code></pre></div></td></tr></table></figure><h2 id="4-远程操作"><a href="#4-远程操作" class="headerlink" title="4.远程操作"></a>4.远程操作</h2><h3 id="绑定仓库"><a href="#绑定仓库" class="headerlink" title="绑定仓库"></a>绑定仓库</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git remote add origin https://gitee.com/group-8-dian/hsp.git <span class="hljs-comment">#将本地仓库与远程仓库绑定</span><br></code></pre></div></td></tr></table></figure><h3 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成<strong>SSH key</strong></h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;邮件地址&quot;</span><br></code></pre></div></td></tr></table></figure><p>然后连续3次回车，会在用户目录下生成一个文件，找到<code>.ssh\id_rsa.pub</code>文件，打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p>将刚复制的内容粘贴到key那里，title随便填，保存</p><p><img src="https://gitee.com/lingdiand/image-repo/raw/master/20210724221458.png"></p><p>测试是否成功</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com <span class="hljs-comment"># 注意邮箱地址不用改</span><br></code></pre></div></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git push origin master  <span class="hljs-comment">#将本地仓库推送到远程仓库</span><br></code></pre></div></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git pull origin master<span class="hljs-comment">#下载远程仓库的项目(团队开发要先下载再上传)</span><br></code></pre></div></td></tr></table></figure><blockquote><p> pull远程仓库后，本地再新建一个分支需要设置上流分支才可以push</p><p> 而从远程分支 checkout 出来的本地分支，即checkout分支本身来自远程仓库，称为跟踪分支(tracking  branch)。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来</p><p> 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull  一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支</p></blockquote><h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="1-git-fetch和git-pull区别"><a href="#1-git-fetch和git-pull区别" class="headerlink" title="1.git fetch和git pull区别"></a>1.git fetch和git pull区别</h2><blockquote><p>pull=fetch+merge    git fetch并没有更改本地仓库的代码，只是拉取了远程仓库的commitID</p></blockquote><blockquote><p><strong>git fetch</strong><br>比如本地仓库的节点为1-&gt;2，此时head指针指向2。远程仓库为1-&gt;2-&gt;3-&gt;4，git fetch后本地仓库变为1-&gt;2-&gt;3-&gt;4，本地仓库的12加上远程仓库的34，但是head指针还是指向2，并没有进行合并</p></blockquote><p><img src="https://pic3.zhimg.com/50/v2-686ae54f78ea69b6c00cc8b159cf7369_720w.webp?source=1940ef5c"></p><blockquote><p><strong>git pull</strong></p><p>最上面的节点合并了箭头两个节点的内容</p></blockquote><p><img src="https://pic3.zhimg.com/50/v2-1298832b975cf9cf0ad6c399ec5da32d_720w.webp?source=1940ef5c"></p><p>可以看到，Git中最重要的是commitID，我们需要通过它进行各种操作，通过<strong>head</strong>指针指向某一个commitID</p><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针，是commit序列的集合载体</p><p><a href="https://www.bilibili.com/video/BV1BE411g7SV">https://www.bilibili.com/video/BV1BE411g7SV</a></p><p><a href="https://blog.csdn.net/halaoda/article/details/78661334">https://blog.csdn.net/halaoda/article/details/78661334</a>    </p><h2 id="2-git创建分支并推送到远程"><a href="#2-git创建分支并推送到远程" class="headerlink" title="2.git创建分支并推送到远程"></a>2.git创建分支并推送到远程</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git checkout -b dev  <span class="hljs-comment">#本地创建dev分支</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git push origin dev:dev<span class="hljs-comment">#将dev分支推送至远端。冒号前的dev指本地dev，冒号后的dev指远端的，没有会自动创建</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git branch --set-upstream-to=origin/dev  <span class="hljs-comment">#建立与远端的链接，这样代码才能提交上去</span><br></code></pre></div></td></tr></table></figure><h2 id="3-删除分支"><a href="#3-删除分支" class="headerlink" title="3.删除分支"></a>3.删除分支</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git branch -d dev<span class="hljs-comment">#删除本地分支</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git push origin :dev <span class="hljs-comment">#在origin repository里面查找dev。用一个空的去更新它，就相当于删除了</span><br>git push origin --delete dev<br></code></pre></div></td></tr></table></figure><h2 id="4-git多人操作同一分支"><a href="#4-git多人操作同一分支" class="headerlink" title="4.git多人操作同一分支"></a>4.git多人操作同一分支</h2><ul><li><p><strong>不同人修改了不同文件</strong></p><p>首先使用<code>fetch</code>命令将远端仓库的变更拉取下来，再使用<code>merge</code>合并当前分支和远端分支，然后向远端进行<code>push</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git fetch origin dev //拉取<br>git merge dev dev //本地合并<br>git push origin dev //推送<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>不同人修改了相同文件的不同区域</strong></p><p>和第一步相同，因为在git中修改的是文件的不同位置，git可以智能的帮我们进行commit</p></li><li><p><strong>不同人修改了相同文件的相同区域</strong></p><p>不同人修改了同一文件的相同区域时，后push到远端的人在push时会报错，需要我们pull拉取到最新的</p><p>使用git pull拉取远端的最新内容时，git会提醒需要解决冲突，需要手动解决，解决冲突后重新commit后push即可。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/04/02/hello-world/"/>
    <url>/2021/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
